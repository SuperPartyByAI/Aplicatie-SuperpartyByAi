diff --git a/functions/chatEventOps.js b/functions/chatEventOps.js
index dae96e1b..af050ea8 100644
--- a/functions/chatEventOps.js
+++ b/functions/chatEventOps.js
@@ -186,13 +186,19 @@ function sanitizeUpdateFields(data) {
   return out;
 }
 
-exports.chatEventOps = onCall(
-  { 
-    region: 'us-central1', 
-    timeoutSeconds: 30,
-    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
-  },
-  async (request) => {
+// Internal handler function (can be called directly or via onCall)
+async function chatEventOpsHandler(request) {
+  const requestId = request.data?.clientRequestId || `chatEventOps_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+  const startTime = Date.now();
+  
+  try {
+    console.log(`[${requestId}] chatEventOps called`, {
+      uid: request.auth?.uid,
+      email: request.auth?.token?.email,
+      textLength: (request.data?.text || '').length,
+      dryRun: request.data?.dryRun === true,
+    });
+
     // Require authentication (all authenticated users can use this)
     const auth = requireAuth(request);
     const { uid, email } = auth;
@@ -201,7 +207,10 @@ exports.chatEventOps = onCall(
     const employeeInfo = await isEmployee(uid, email);
 
     const text = (request.data?.text || '').toString().trim();
-    if (!text) throw new HttpsError('invalid-argument', 'Lipse»ôte "text".');
+    if (!text) {
+      console.error(`[${requestId}] Missing text parameter`);
+      throw new HttpsError('invalid-argument', 'Lipse»ôte "text".');
+    }
 
     // DryRun mode: parse command but don't execute (for preview)
     const dryRun = request.data?.dryRun === true;
@@ -209,7 +218,7 @@ exports.chatEventOps = onCall(
     // Access GROQ API key from secret
     const groqKey = groqApiKey.value();
     if (!groqKey) {
-      console.error('[chatEventOps] GROQ_API_KEY not available');
+      console.error(`[${requestId}] GROQ_API_KEY not available`);
       throw new HttpsError('failed-precondition', 'Lipse»ôte GROQ_API_KEY.');
     }
 
@@ -481,7 +490,14 @@ DacƒÉ utilizatorul cere "»ôterge", √Æntoarce action:"ARCHIVE" sau "NONE".
       }
 
       const ref = await db.collection('evenimente').add(doc);
-      return { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat »ôi adƒÉugat √Æn Evenimente.`, dryRun: false };
+      const result = { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat »ôi adƒÉugat √Æn Evenimente.`, dryRun: false };
+      console.log(`[${requestId}] Event created`, {
+        eventId: ref.id,
+        eventShortId: doc.eventShortId,
+        date: doc.date,
+        address: doc.address,
+      });
+      return result;
     }
 
     if (action === 'UPDATE') {
@@ -627,8 +643,36 @@ DacƒÉ utilizatorul cere "»ôterge", √Æntoarce action:"ARCHIVE" sau "NONE".
       return { ok: true, action: 'UNARCHIVE', eventId, message: `Eveniment dezarhivat: ${eventId}`, dryRun: false };
     }
 
-    return { ok: false, action: 'NONE', message: `Ac»õiune necunoscutƒÉ: ${action}`, raw };
+    const result = { ok: false, action: 'NONE', message: `Ac»õiune necunoscutƒÉ: ${action}`, raw };
+    const duration = Date.now() - startTime;
+    console.log(`[${requestId}] chatEventOps completed`, {
+      action: result.action,
+      ok: result.ok,
+      durationMs: duration,
+    });
+    return result;
+  } catch (error) {
+    const duration = Date.now() - startTime;
+    console.error(`[${requestId}] chatEventOps error`, {
+      error: error.message,
+      stack: error.stack,
+      durationMs: duration,
+    });
+    throw error;
   }
+}
+
+// Export as onCall handler
+exports.chatEventOps = onCall(
+  { 
+    region: 'us-central1', 
+    timeoutSeconds: 30,
+    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
+  },
+  chatEventOpsHandler
 );
 
+// Export handler function for direct calls (e.g., from chatWithAI)
+exports.chatEventOpsHandler = chatEventOpsHandler;
+
 // Force redeploy Fri Jan  9 14:06:54 UTC 2026
diff --git a/functions/index.js b/functions/index.js
index db7cd048..4ea5b3ca 100644
--- a/functions/index.js
+++ b/functions/index.js
@@ -546,22 +546,38 @@ Scrie "da" pentru a confirma »ôi crea evenimentul, sau "anuleazƒÉ" pentru a renu
 
         if (step === 'confirm') {
           if (userText === 'da' || userText === 'confirm' || userText === 'confirma') {
-            // Call chatEventOps to create event
-            const chatEventOps = require('./chatEventOps');
-            
+            // Call chatEventOps via exported callable (proper way)
             const eventText = `NoteazƒÉ eveniment pentru ${eventData.sarbatoritNume}, ${eventData.sarbatoritVarsta} ani, pe ${eventData.date} la ${eventData.address}`;
+            const clientRequestId = `interactive_${currentSessionId}_${Date.now()}`;
+            
+            console.log(`[${requestId}] Creating event via chatEventOps`, {
+              clientRequestId,
+              sessionId: currentSessionId,
+              eventData: {
+                name: eventData.sarbatoritNume,
+                age: eventData.sarbatoritVarsta,
+                date: eventData.date,
+                address: eventData.address,
+              },
+            });
             
             try {
-              const eventResult = await chatEventOps({
+              // Use the exported handler function directly (not the onCall wrapper)
+              const { chatEventOpsHandler } = require('./chatEventOps');
+              
+              // Call handler directly with request-like object
+              const eventResult = await chatEventOpsHandler({
                 data: {
                   text: eventText,
                   dryRun: false,
-                  clientRequestId: `interactive_${currentSessionId}_${Date.now()}`
+                  clientRequestId,
                 },
-                auth: request.auth
-              }, {
-                status: () => ({ json: () => {} }),
-                json: (data) => data
+                auth: request.auth,
+              });
+              
+              console.log(`[${requestId}] Event created successfully`, {
+                eventId: eventResult.eventId,
+                clientRequestId,
               });
               
               // Clear conversation state
@@ -575,7 +591,11 @@ Scrie "da" pentru a confirma »ôi crea evenimentul, sau "anuleazƒÉ" pentru a renu
                 eventId: eventResult.eventId
               };
             } catch (error) {
-              console.error(`[${requestId}] Error creating event:`, error);
+              console.error(`[${requestId}] Error creating event:`, {
+                error: error.message,
+                stack: error.stack,
+                clientRequestId,
+              });
               await stateRef.delete();
               
               return {
diff --git a/functions/whatsappProxy.js b/functions/whatsappProxy.js
index f85b42ec..dea3ee18 100644
--- a/functions/whatsappProxy.js
+++ b/functions/whatsappProxy.js
@@ -478,12 +478,16 @@ async function getAccountsHandler(req, res) {
       // Lazy-load Railway base URL (computed at handler runtime, not module load time)
       const railwayBaseUrl = getRailwayBaseUrl();
       if (!railwayBaseUrl) {
+        console.error('[whatsappProxy/getAccounts] WHATSAPP_RAILWAY_BASE_URL missing');
+        console.error('[whatsappProxy/getAccounts] process.env.WHATSAPP_RAILWAY_BASE_URL:', process.env.WHATSAPP_RAILWAY_BASE_URL ? 'SET' : 'NOT SET');
         return res.status(500).json({
           success: false,
           error: 'configuration_missing',
           message: 'WHATSAPP_RAILWAY_BASE_URL must be set via environment variable or functions.config().whatsapp.railway_base_url',
         });
       }
+      
+      console.log('[whatsappProxy/getAccounts] Railway URL:', railwayBaseUrl.substring(0, 30) + '...');
 
       // Forward to Railway backend
       const railwayUrl = `${railwayBaseUrl}/api/whatsapp/accounts`;
diff --git a/superparty_flutter/lib/router/app_router.dart b/superparty_flutter/lib/router/app_router.dart
index 08f5e543..0e7d80ad 100644
--- a/superparty_flutter/lib/router/app_router.dart
+++ b/superparty_flutter/lib/router/app_router.dart
@@ -2,7 +2,7 @@ import 'dart:async';
 import 'dart:io';
 import 'dart:convert';
 
-import 'package:flutter/foundation.dart';
+import 'package:flutter/foundation.dart' show kDebugMode;
 import 'package:flutter/material.dart';
 import 'package:go_router/go_router.dart';
 
@@ -17,6 +17,7 @@ import '../screens/disponibilitate/disponibilitate_screen.dart';
 import '../screens/salarizare/salarizare_screen.dart';
 import '../screens/centrala/centrala_screen.dart';
 import '../screens/whatsapp/whatsapp_screen.dart';
+import '../screens/debug/whatsapp_diagnostics_screen.dart';
 import '../screens/whatsapp/whatsapp_accounts_screen.dart';
 import '../screens/whatsapp/whatsapp_inbox_screen.dart';
 import '../screens/whatsapp/whatsapp_chat_screen.dart';
@@ -116,6 +117,12 @@ class AppRouter {
           child: const WhatsAppScreen(),
         ),
         routes: [
+          // Debug diagnostics (only in debug mode)
+          if (kDebugMode)
+            GoRoute(
+              path: 'diagnostics',
+              builder: (context, state) => const WhatsAppDiagnosticsScreen(),
+            ),
           GoRoute(
             path: 'accounts',
             builder: (context, state) => AuthGate(
diff --git a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
index 58e367f6..86e30e71 100644
--- a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
+++ b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
@@ -372,6 +372,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         // Generate unique clientRequestId for idempotency
         final clientRequestId = 'req_${DateTime.now().millisecondsSinceEpoch}_${Random().nextInt(9999)}';
         
+        debugPrint('[AIChat] Calling chatEventOps (preview): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=true');
+        
         // Call chatEventOps with dryRun=true for preview
         final eventCallable =
             FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -385,6 +387,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
           'clientRequestId': clientRequestId,
         });
         
+        debugPrint('[AIChat] chatEventOps preview result: requestId=$clientRequestId, ok=${previewResult.data['ok']}, action=${previewResult.data['action']}');
+        
         final previewData = Map<String, dynamic>.from(previewResult.data);
         
         // Remove placeholder and show preview
@@ -1308,6 +1312,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
     });
     _scrollToBottomSoon();
 
+    debugPrint('[AIChat] Calling chatEventOps (create): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=false');
+    
     try {
       final eventCallable =
           FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -1320,6 +1326,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         'dryRun': false,
         'clientRequestId': clientRequestId,
       });
+      
+      debugPrint('[AIChat] chatEventOps create result: requestId=$clientRequestId, ok=${result.data['ok']}, action=${result.data['action']}, eventId=${result.data['eventId']}');
 
       final data = Map<String, dynamic>.from(result.data);
       final ok = data['ok'] == true;
diff --git a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
index 4501cfc3..9a228d3e 100644
--- a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
+++ b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
@@ -2,6 +2,7 @@ import 'dart:ui' show ImageFilter;
 import 'dart:io';
 import 'dart:convert';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:cloud_firestore/cloud_firestore.dart';
 import '../../models/event_model.dart';
 import '../../widgets/modals/range_modal.dart';
@@ -512,6 +513,7 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         }
 
         if (snapshot.hasError) {
+          debugPrint('[EvenimenteScreen] Firestore error: ${snapshot.error}');
           return Center(
             child: Text(
               'Eroare: ${snapshot.error}',
@@ -523,8 +525,14 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         final events = snapshot.data?.docs.map((doc) {
           return EventModel.fromFirestore(doc);
         }).toList() ?? [];
+        
+        debugPrint('[EvenimenteScreen] Loaded ${events.length} events from Firestore');
+        debugPrint('[EvenimenteScreen] Events with isArchived=false: ${events.where((e) => !e.isArchived).length}');
+        
         _allEvents = events; // Cache for CodeInfoModal
         final filteredEvents = _applyFilters(events);
+        
+        debugPrint('[EvenimenteScreen] Filtered events count: ${filteredEvents.length}');
 
         if (filteredEvents.isEmpty) {
           return Center(
diff --git a/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart b/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
index 5f83fff1..20fb648a 100644
--- a/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
+++ b/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
@@ -1,5 +1,6 @@
 import 'dart:convert';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:qr_flutter/qr_flutter.dart';
 import 'package:url_launcher/url_launcher.dart';
 import '../../services/whatsapp_api_service.dart';
@@ -30,25 +31,42 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
   @override
   void initState() {
     super.initState();
+    debugPrint('[WhatsAppAccountsScreen] initState: loading accounts');
     _loadAccounts();
   }
 
   Future<void> _loadAccounts() async {
     final myToken = ++_loadRequestToken;
     
+    debugPrint('[WhatsAppAccountsScreen] _loadAccounts: starting (token=$myToken)');
+    
     setState(() {
       _isLoading = true;
       _error = null;
     });
 
     try {
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: calling getAccounts()');
       final response = await _apiService.getAccounts();
       
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: response received (token=$myToken, success=${response['success']}, accountsCount=${(response['accounts'] as List?)?.length ?? 0})');
+      
       // Ignore late responses (if another load started)
-      if (myToken != _loadRequestToken) return;
+      if (myToken != _loadRequestToken) {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: ignoring late response (token mismatch)');
+        return;
+      }
       
       if (response['success'] == true) {
         final accounts = response['accounts'] as List<dynamic>? ?? [];
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: success, ${accounts.length} accounts');
+        
+        // Log account statuses for debugging
+        for (final account in accounts) {
+          final acc = account as Map<String, dynamic>;
+          debugPrint('[WhatsAppAccountsScreen] Account: id=${acc['id']}, status=${acc['status']}, hasQR=${acc['qrCode'] != null}');
+        }
+        
         if (mounted && myToken == _loadRequestToken) {
           setState(() {
             _accounts = accounts.cast<Map<String, dynamic>>();
@@ -56,6 +74,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
           });
         }
       } else {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: failed - ${response['message']}');
         if (mounted && myToken == _loadRequestToken) {
           setState(() {
             _error = response['message'] ?? 'Failed to load accounts';
@@ -64,8 +83,12 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         }
       }
     } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: exception - $e');
       // Ignore late responses
-      if (myToken != _loadRequestToken) return;
+      if (myToken != _loadRequestToken) {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: ignoring late exception (token mismatch)');
+        return;
+      }
       
       if (mounted) {
         setState(() {
@@ -122,10 +145,18 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
       ),
     );
 
-    if (result != true) return;
+    if (result != true) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: cancelled');
+      return;
+    }
 
     // Guard: prevent double-tap
-    if (_isAddingAccount) return;
+    if (_isAddingAccount) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: already in progress, skipping');
+      return;
+    }
+    
+    debugPrint('[WhatsAppAccountsScreen] _addAccount: starting (name=${nameController.text.trim()}, phone=${phoneController.text.trim()})');
     setState(() => _isAddingAccount = true);
 
     try {
@@ -134,6 +165,8 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         phone: phoneController.text.trim(),
       );
 
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: response received (success=${response['success']}, accountId=${response['account']?['id'] ?? response['accountId']})');
+
       if (mounted) {
         if (response['success'] == true) {
           ScaffoldMessenger.of(context).showSnackBar(
@@ -142,8 +175,10 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
               backgroundColor: Colors.green,
             ),
           );
+          debugPrint('[WhatsAppAccountsScreen] _addAccount: success, reloading accounts');
           await _loadAccounts();
         } else {
+          debugPrint('[WhatsAppAccountsScreen] _addAccount: failed - ${response['message']}');
           ScaffoldMessenger.of(context).showSnackBar(
             SnackBar(
               content: Text(response['message'] ?? 'Failed to add account'),
@@ -153,6 +188,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         }
       }
     } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: exception - $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(
@@ -170,13 +206,19 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
 
   Future<void> _regenerateQr(String accountId) async {
     // Guard: prevent double-tap
-    if (_regeneratingQr.contains(accountId)) return;
+    if (_regeneratingQr.contains(accountId)) {
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: already in progress for $accountId');
+      return;
+    }
     
+    debugPrint('[WhatsAppAccountsScreen] _regenerateQr: starting for accountId=$accountId');
     setState(() => _regeneratingQr.add(accountId));
 
     try {
       final response = await _apiService.regenerateQr(accountId: accountId);
 
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: response received (success=${response['success']}, message=${response['message']})');
+
       if (mounted) {
         if (response['success'] == true) {
           ScaffoldMessenger.of(context).showSnackBar(
@@ -186,9 +228,11 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
             ),
           );
           // Reload accounts to get new QR code
+          debugPrint('[WhatsAppAccountsScreen] _regenerateQr: waiting 2s then reloading accounts');
           await Future.delayed(const Duration(seconds: 2));
           await _loadAccounts();
         } else {
+          debugPrint('[WhatsAppAccountsScreen] _regenerateQr: failed - ${response['message']}');
           ScaffoldMessenger.of(context).showSnackBar(
             SnackBar(
               content: Text(response['message'] ?? 'Failed to regenerate QR'),
@@ -198,6 +242,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         }
       }
     } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: exception - $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(
@@ -288,11 +333,16 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
     final status = account['status'] as String? ?? 'unknown';
     final qrCode = account['qrCode'] as String?;
     final pairingCode = account['pairingCode'] as String?;
+    final lastError = account['lastError'] as String?;
+    final passiveModeReason = account['passiveModeReason'] as String?;
 
     final statusColor = _getStatusColor(status);
     final showQr = status == 'qr_ready' && qrCode != null;
     // When showQr is true, qrCode is guaranteed non-null
     final qrCodeData = qrCode ?? '';
+    
+    // Show passive mode warning if status is passive
+    final isPassive = status == 'passive' || passiveModeReason != null;
 
     return Card(
       margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
@@ -335,7 +385,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                     border: Border.all(color: statusColor),
                   ),
                   child: Text(
-                    status.toUpperCase(),
+                    _getStatusDisplayText(status),
                     style: TextStyle(
                       fontSize: 12,
                       fontWeight: FontWeight.bold,
@@ -345,6 +395,53 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                 ),
               ],
             ),
+            if (isPassive) ...[
+              const SizedBox(height: 12),
+              Container(
+                padding: const EdgeInsets.all(12),
+                decoration: BoxDecoration(
+                  color: Colors.purple.withValues(alpha: 0.1),
+                  borderRadius: BorderRadius.circular(8),
+                  border: Border.all(color: Colors.purple),
+                ),
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Row(
+                      children: [
+                        const Icon(Icons.warning_amber_rounded, color: Colors.purple, size: 20),
+                        const SizedBox(width: 8),
+                        const Text(
+                          'Backend in PASSIVE mode',
+                          style: TextStyle(
+                            fontSize: 14,
+                            fontWeight: FontWeight.bold,
+                            color: Colors.purple,
+                          ),
+                        ),
+                      ],
+                    ),
+                    const SizedBox(height: 4),
+                    Text(
+                      passiveModeReason ?? lastError ?? 'Lock not acquired by this instance',
+                      style: const TextStyle(
+                        fontSize: 12,
+                        color: Colors.purple,
+                      ),
+                    ),
+                    const SizedBox(height: 4),
+                    const Text(
+                      'Backend will retry lock acquisition automatically. Accounts cannot connect until backend is ACTIVE.',
+                      style: TextStyle(
+                        fontSize: 11,
+                        color: Colors.purple,
+                        fontStyle: FontStyle.italic,
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+            ],
             if (showQr) ...[
               const SizedBox(height: 16),
               Center(
@@ -463,10 +560,25 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         return Colors.blue;
       case 'disconnected':
         return Colors.red;
+      case 'passive':
+        return Colors.purple; // Purple for passive mode
+      case 'needs_qr':
+        return Colors.amber;
       default:
         return Colors.grey;
     }
   }
+  
+  String _getStatusDisplayText(String status) {
+    switch (status.toLowerCase()) {
+      case 'passive':
+        return 'PASSIVE (Backend not active)';
+      case 'needs_qr':
+        return 'NEEDS QR';
+      default:
+        return status.toUpperCase();
+    }
+  }
 
   @override
   Widget build(BuildContext context) {
diff --git a/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart b/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
index 113179c6..71b0e87b 100644
--- a/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
+++ b/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
@@ -1,6 +1,7 @@
 import 'package:cloud_firestore/cloud_firestore.dart';
 import 'package:firebase_auth/firebase_auth.dart';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:go_router/go_router.dart';
 import 'package:intl/intl.dart';
 
@@ -53,9 +54,12 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
   Future<void> _sendMessage() async {
     final text = _messageController.text.trim();
     if (text.isEmpty || _isSending || _accountId == null || _threadId == null || _clientJid == null) {
+      debugPrint('[WhatsAppChatScreen] _sendMessage: validation failed (isEmpty=${text.isEmpty}, isSending=$_isSending, accountId=$_accountId, threadId=$_threadId, clientJid=$_clientJid)');
       return;
     }
 
+    debugPrint('[WhatsAppChatScreen] _sendMessage: starting (accountId=$_accountId, threadId=$_threadId, textLength=${text.length})');
+    
     setState(() {
       _isSending = true;
     });
@@ -63,7 +67,9 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
     try {
       final clientMessageId = 'client_${DateTime.now().millisecondsSinceEpoch}';
       
-      await _apiService.sendViaProxy(
+      debugPrint('[WhatsAppChatScreen] _sendMessage: calling sendViaProxy (clientMessageId=$clientMessageId)');
+      
+      final result = await _apiService.sendViaProxy(
         threadId: _threadId!,
         accountId: _accountId!,
         toJid: _clientJid!,
@@ -71,11 +77,14 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
         clientMessageId: clientMessageId,
       );
 
+      debugPrint('[WhatsAppChatScreen] _sendMessage: success (requestId=${result['requestId']}, duplicate=${result['duplicate']})');
+
       if (mounted) {
         _messageController.clear();
         _scrollToBottom();
       }
     } catch (e) {
+      debugPrint('[WhatsAppChatScreen] _sendMessage: exception - $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('Error sending message: $e')),
diff --git a/superparty_flutter/lib/services/whatsapp_api_service.dart b/superparty_flutter/lib/services/whatsapp_api_service.dart
index cb8d90a5..6d3a2d39 100644
--- a/superparty_flutter/lib/services/whatsapp_api_service.dart
+++ b/superparty_flutter/lib/services/whatsapp_api_service.dart
@@ -81,10 +81,21 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
+      final endpointUrl = '$functionsUrl/whatsappProxySend';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] sendViaProxy: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  threadId: $threadId, accountId: $accountId, toJid: $toJid');
+      debugPrint('  textLength: ${text.length}');
+
       // Call Functions proxy with timeout
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxySend'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -100,8 +111,13 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
+      debugPrint('[WhatsAppApiService] sendViaProxy: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
+
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
+        debugPrint('[WhatsAppApiService] sendViaProxy: error=${errorBody?['error']}, message=${errorBody?['message']}');
         throw ErrorMapper.fromHttpException(
           response.statusCode,
           errorBody?['message'] as String?,
@@ -109,6 +125,7 @@ class WhatsAppApiService {
       }
 
       final data = jsonDecode(response.body) as Map<String, dynamic>;
+      debugPrint('[WhatsAppApiService] sendViaProxy: success (requestId=${data['requestId']}, duplicate=${data['duplicate']})');
       return data;
     });
   }
@@ -132,12 +149,19 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] getAccounts: calling proxy (uid=${user.uid.substring(0, 8)}...)');
+      final endpointUrl = '$functionsUrl/whatsappProxyGetAccounts';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] getAccounts: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .get(
-            Uri.parse('$functionsUrl/whatsappProxyGetAccounts'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -146,7 +170,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] getAccounts: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] getAccounts: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
@@ -186,12 +212,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] addAccount: calling proxy (uid=${user.uid.substring(0, 8)}..., name=$name, phone=$phone)');
+      final endpointUrl = '$functionsUrl/whatsappProxyAddAccount';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] addAccount: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  name: $name, phone: $phone');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyAddAccount'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -204,7 +238,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] addAccount: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] addAccount: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
@@ -241,12 +277,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy (uid=${user.uid.substring(0, 8)}..., accountId=$accountId)');
+      final endpointUrl = '$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  accountId: $accountId');
 
       // Call Functions proxy with Authorization header (query param for accountId)
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -255,7 +299,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] regenerateQr: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] regenerateQr: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
diff --git a/whatsapp-backend/lib/wa-bootstrap.js b/whatsapp-backend/lib/wa-bootstrap.js
index 34052aa9..e5fe8484 100644
--- a/whatsapp-backend/lib/wa-bootstrap.js
+++ b/whatsapp-backend/lib/wa-bootstrap.js
@@ -132,26 +132,48 @@ function stopPassiveRetryLoop() {
  */
 function setupLockLostHandler() {
   // Check lock status every 30s
-  setInterval(async () => {
-    if (!waIntegration || !isActive) return;
+  const lockCheckInterval = setInterval(async () => {
+    if (!waIntegration || !isActive) {
+      // If not active, stop checking (will be restarted when active)
+      clearInterval(lockCheckInterval);
+      return;
+    }
 
-    const lockStatus = await waIntegration.stability.lock.getStatus();
+    try {
+      const lockStatus = await waIntegration.stability.lock.getStatus();
 
-    if (!lockStatus.isHolder) {
-      console.error('[WABootstrap] üö® LOCK LOST - entering PASSIVE mode');
-      console.error(
-        `[WABootstrap] lock_lost_entering_passive instanceId=${instanceId} leaseEpoch=${lockStatus.leaseEpoch || 'unknown'}`
-      );
+      if (!lockStatus.isHolder) {
+        console.error('[WABootstrap] üö® LOCK LOST - entering PASSIVE mode');
+        console.error(
+          `[WABootstrap] lock_lost_entering_passive instanceId=${instanceId} leaseEpoch=${lockStatus.leaseEpoch || 'unknown'} holderInstanceId=${lockStatus.holderInstanceId || 'unknown'}`
+        );
 
-      isActive = false;
+        isActive = false;
+        clearInterval(lockCheckInterval); // Stop checking when passive
 
-      // TODO: Close all Baileys sockets immediately
-      // This will be implemented when integrating with actual socket management
+        // TODO: Close all Baileys sockets immediately
+        // This will be implemented when integrating with actual socket management
 
-      console.log('[WABootstrap] All Baileys connections closed');
-      console.log('[WABootstrap] Now in PASSIVE mode');
+        console.log('[WABootstrap] All Baileys connections closed');
+        console.log('[WABootstrap] Now in PASSIVE mode - will retry lock acquisition');
+        
+        // Restart passive retry loop to re-acquire lock
+        if (waIntegration && db) {
+          startPassiveRetryLoop(db);
+        }
+      } else {
+        // Lock still held - log periodically for debugging
+        if (Date.now() % 300000 < 30000) { // Log every ~5 minutes
+          console.log(`[WABootstrap] Lock check: still holder (leaseEpoch: ${lockStatus.leaseEpoch || 'unknown'})`);
+        }
+      }
+    } catch (error) {
+      console.error('[WABootstrap] Lock status check failed:', error.message);
+      // Continue checking on next interval
     }
   }, 30000);
+  
+  console.log('[WABootstrap] Lock lost handler started (checks every 30s)');
 }
 
 /**
diff --git a/whatsapp-backend/server.js b/whatsapp-backend/server.js
index 0ae451ce..26b60809 100644
--- a/whatsapp-backend/server.js
+++ b/whatsapp-backend/server.js
@@ -1008,7 +1008,17 @@ function isTerminalLogout(reasonCode) {
 async function createConnection(accountId, name, phone) {
   // HARD GATE: PASSIVE mode - do NOT start Baileys connections
   if (!waBootstrap.canStartBaileys()) {
+    const status = await waBootstrap.getWAStatus();
     console.log(`‚è∏Ô∏è  [${accountId}] PASSIVE mode - cannot start Baileys connection (lock not held)`);
+    console.log(`‚è∏Ô∏è  [${accountId}] PASSIVE mode details: reason=${status.reason || 'unknown'}, instanceId=${status.instanceId || 'unknown'}`);
+    
+    // Save passive status to Firestore so Flutter can display it
+    await saveAccountToFirestore(accountId, {
+      status: 'passive',
+      lastError: `Backend in PASSIVE mode: ${status.reason || 'lock not acquired'}`,
+      passiveModeReason: status.reason || 'lock_not_acquired',
+    }).catch(err => console.error(`‚ùå [${accountId}] Failed to save passive status:`, err));
+    
     return;
   }
 
@@ -1336,13 +1346,26 @@ async function createConnection(accountId, name, phone) {
         const rawReason = boomStatus ?? errorCode ?? 'unknown';
         
         // Normalize reason to number for comparison
-        const reason = typeof rawReason === 'number' ? rawReason : (typeof rawReason === 'string' ? parseInt(rawReason, 10) || 'unknown' : 'unknown');
+        // CRITICAL: Handle 515 (restart required) explicitly
+        let reason = typeof rawReason === 'number' ? rawReason : (typeof rawReason === 'string' ? parseInt(rawReason, 10) || 'unknown' : 'unknown');
+        
+        // CRITICAL: If error message contains "restart required" but statusCode is not 515, set it
+        if (error?.message && error.message.includes('restart required') && reason !== 515) {
+          console.log(`üîç [${accountId}] Detected "restart required" in message but statusCode is ${reason}, normalizing to 515`);
+          reason = 515;
+        }
         
         // Extract Boom error details for better logging
         const boomPayload = error?.output?.payload;
         const errorMessage = error?.message || 'No error message';
         const errorStack = error?.stack;
         
+        // CRITICAL: Detect reason code 515 (restart required) - common in pairing phase
+        // 515 = "Stream Errored (restart required)" - requires socket recreation + new QR
+        const isRestartRequired = (typeof reason === 'number' && reason === 515) || 
+                                 (typeof boomStatus === 'number' && boomStatus === 515) ||
+                                 (errorMessage && errorMessage.includes('restart required'));
+        
         // Log detailed disconnect information (helps diagnose "unknown" reasons)
         console.error(`üîå [${accountId}] connection.update: close`, {
           sessionId: account.sessionId || 'unknown', // Connection session ID for debugging
@@ -1356,6 +1379,7 @@ async function createConnection(accountId, name, phone) {
           shouldReconnect: reason !== DisconnectReason.loggedOut,
           currentStatus: account.status,
           isPairingPhase: ['qr_ready', 'awaiting_scan', 'pairing', 'connecting'].includes(account.status),
+          isRestartRequired: isRestartRequired, // CRITICAL: Flag for 515 handling
           lastDisconnect: lastDisconnect ? {
             error: error ? {
               name: error.name,
@@ -1369,7 +1393,9 @@ async function createConnection(accountId, name, phone) {
           } : undefined,
         });
         
-        const shouldReconnect = reason !== DisconnectReason.loggedOut;
+        // CRITICAL FIX: For 515 (restart required), always reconnect (even in pairing phase)
+        // 515 means stream errored but session is valid - need new socket + potentially new QR
+        const shouldReconnect = reason !== DisconnectReason.loggedOut || isRestartRequired;
 
         // Define explicit cleanup reasons (only these trigger account deletion)
         // Ensure we compare numbers consistently
@@ -1451,23 +1477,43 @@ async function createConnection(accountId, name, phone) {
           // CRITICAL FIX: Auto-reconnect in pairing phase for transient errors
           // Don't leave account stuck in qr_ready if socket closes due to transient network issue
           // Only skip reconnect if reason is terminal (loggedOut/badSession/unauthorized)
-          if (shouldReconnect && reason !== DisconnectReason.loggedOut) {
+          // SPECIAL HANDLING: 515 (restart required) always triggers reconnect + QR regeneration
+          if (shouldReconnect && (reason !== DisconnectReason.loggedOut || isRestartRequired)) {
             const attempts = reconnectAttempts.get(accountId) || 0;
             const MAX_PAIRING_RECONNECT_ATTEMPTS = parseInt(process.env.MAX_PAIRING_RECONNECT_ATTEMPTS || '10', 10);
             
+            // CRITICAL: For 515, clear QR immediately (will be regenerated on reconnect)
+            if (isRestartRequired) {
+              console.log(`üîÑ [${accountId}] Reason 515 (restart required) - clearing QR, will regenerate on reconnect`);
+              account.qrCode = null;
+              account.status = 'connecting'; // Reset to connecting to trigger new QR generation
+              await saveAccountToFirestore(accountId, {
+                qrCode: null,
+                status: 'connecting',
+                lastDisconnectReason: 'restart_required_515',
+                lastDisconnectCode: 515,
+              });
+            }
+            
             if (attempts < MAX_PAIRING_RECONNECT_ATTEMPTS) {
               // Exponential backoff for pairing phase: 1s, 2s, 4s, 8s, 16s, 30s (max)
-              const backoff = Math.min(1000 * Math.pow(2, attempts), 30000);
+              // For 515, use shorter backoff (2s, 4s, 8s) since it's a known recoverable error
+              const baseBackoff = isRestartRequired ? 2000 : 1000;
+              const backoff = Math.min(baseBackoff * Math.pow(2, attempts), 30000);
               console.log(
-                `üîÑ [${accountId}] Pairing phase reconnect in ${backoff}ms (attempt ${attempts + 1}/${MAX_PAIRING_RECONNECT_ATTEMPTS}, reason: ${reason})`
+                `üîÑ [${accountId}] Pairing phase reconnect in ${backoff}ms (attempt ${attempts + 1}/${MAX_PAIRING_RECONNECT_ATTEMPTS}, reason: ${reason}${isRestartRequired ? ' [515 restart required]' : ''})`
               );
               
               reconnectAttempts.set(accountId, attempts + 1);
               
               setTimeout(() => {
                 const acc = connections.get(accountId);
-                if (acc && ['qr_ready', 'awaiting_scan', 'connecting'].includes(acc.status)) {
-                  console.log(`üîÑ [${accountId}] Starting pairing phase reconnect (session will be new)`);
+                if (acc && ['qr_ready', 'awaiting_scan', 'connecting', 'needs_qr'].includes(acc.status)) {
+                  console.log(`üîÑ [${accountId}] Starting pairing phase reconnect (session will be new${isRestartRequired ? ', QR will be regenerated' : ''})`);
+                  // Reset status to connecting to ensure fresh QR generation
+                  if (isRestartRequired) {
+                    acc.status = 'connecting';
+                  }
                   createConnection(accountId, acc.name, acc.phone);
                 }
               }, backoff);
@@ -1476,12 +1522,12 @@ async function createConnection(accountId, name, phone) {
               account.status = 'needs_qr';
               await saveAccountToFirestore(accountId, {
                 status: 'needs_qr',
-                lastError: `Max pairing reconnect attempts (${MAX_PAIRING_RECONNECT_ATTEMPTS}) reached`,
+                lastError: `Max pairing reconnect attempts (${MAX_PAIRING_RECONNECT_ATTEMPTS}) reached${isRestartRequired ? ' (reason: 515 restart required)' : ''}`,
               });
               reconnectAttempts.delete(accountId);
             }
           } else {
-            console.log(`‚è∏Ô∏è  [${accountId}] Pairing phase close: no reconnect (reason: ${reason}, shouldReconnect: ${shouldReconnect})`);
+            console.log(`‚è∏Ô∏è  [${accountId}] Pairing phase close: no reconnect (reason: ${reason}, shouldReconnect: ${shouldReconnect}, isRestartRequired: ${isRestartRequired})`);
           }
           
           return;
@@ -1941,6 +1987,44 @@ app.get('/health', (req, res) => {
   });
 });
 
+// /api/longrun/status-now endpoint - comprehensive status including passive mode
+app.get('/api/longrun/status-now', requireAdmin, async (req, res) => {
+  try {
+    const status = await waBootstrap.getWAStatus();
+    const isActive = waBootstrap.isActiveMode();
+    
+    // Get account statuses
+    const accountStatuses = [];
+    for (const [accountId, account] of connections.entries()) {
+      accountStatuses.push({
+        accountId,
+        name: account.name,
+        phone: account.phone,
+        status: account.status,
+        hasQR: !!account.qrCode,
+        sessionId: account.sessionId,
+      });
+    }
+    
+    res.json({
+      waMode: isActive ? 'active' : 'passive',
+      waStatus: status.waStatus || (isActive ? 'RUNNING' : 'NOT_RUNNING'),
+      instanceId: status.instanceId || 'unknown',
+      reason: status.reason || (isActive ? null : 'lock_not_acquired'),
+      lockStatus: status.lockStatus || 'unknown',
+      accounts: accountStatuses,
+      accountsCount: connections.size,
+      timestamp: new Date().toISOString(),
+    });
+  } catch (error) {
+    console.error('[status-now] Error:', error.message);
+    res.status(500).json({
+      error: error.message,
+      timestamp: new Date().toISOString(),
+    });
+  }
+});
+
 // Expose test token (temporary for orchestrator)
 app.get('/api/test/token', (req, res) => {
   if (Date.now() > TEST_TOKEN_EXPIRY) {
