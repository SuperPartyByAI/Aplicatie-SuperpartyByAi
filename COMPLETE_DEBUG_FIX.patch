diff --git a/functions/chatEventOps.js b/functions/chatEventOps.js
index dae96e1b..af050ea8 100644
--- a/functions/chatEventOps.js
+++ b/functions/chatEventOps.js
@@ -186,13 +186,19 @@ function sanitizeUpdateFields(data) {
   return out;
 }
 
-exports.chatEventOps = onCall(
-  { 
-    region: 'us-central1', 
-    timeoutSeconds: 30,
-    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
-  },
-  async (request) => {
+// Internal handler function (can be called directly or via onCall)
+async function chatEventOpsHandler(request) {
+  const requestId = request.data?.clientRequestId || `chatEventOps_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+  const startTime = Date.now();
+  
+  try {
+    console.log(`[${requestId}] chatEventOps called`, {
+      uid: request.auth?.uid,
+      email: request.auth?.token?.email,
+      textLength: (request.data?.text || '').length,
+      dryRun: request.data?.dryRun === true,
+    });
+
     // Require authentication (all authenticated users can use this)
     const auth = requireAuth(request);
     const { uid, email } = auth;
@@ -201,7 +207,10 @@ exports.chatEventOps = onCall(
     const employeeInfo = await isEmployee(uid, email);
 
     const text = (request.data?.text || '').toString().trim();
-    if (!text) throw new HttpsError('invalid-argument', 'LipseÈ™te "text".');
+    if (!text) {
+      console.error(`[${requestId}] Missing text parameter`);
+      throw new HttpsError('invalid-argument', 'LipseÈ™te "text".');
+    }
 
     // DryRun mode: parse command but don't execute (for preview)
     const dryRun = request.data?.dryRun === true;
@@ -209,7 +218,7 @@ exports.chatEventOps = onCall(
     // Access GROQ API key from secret
     const groqKey = groqApiKey.value();
     if (!groqKey) {
-      console.error('[chatEventOps] GROQ_API_KEY not available');
+      console.error(`[${requestId}] GROQ_API_KEY not available`);
       throw new HttpsError('failed-precondition', 'LipseÈ™te GROQ_API_KEY.');
     }
 
@@ -481,7 +490,14 @@ DacÄƒ utilizatorul cere "È™terge", Ã®ntoarce action:"ARCHIVE" sau "NONE".
       }
 
       const ref = await db.collection('evenimente').add(doc);
-      return { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat È™i adÄƒugat Ã®n Evenimente.`, dryRun: false };
+      const result = { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat È™i adÄƒugat Ã®n Evenimente.`, dryRun: false };
+      console.log(`[${requestId}] Event created`, {
+        eventId: ref.id,
+        eventShortId: doc.eventShortId,
+        date: doc.date,
+        address: doc.address,
+      });
+      return result;
     }
 
     if (action === 'UPDATE') {
@@ -627,8 +643,36 @@ DacÄƒ utilizatorul cere "È™terge", Ã®ntoarce action:"ARCHIVE" sau "NONE".
       return { ok: true, action: 'UNARCHIVE', eventId, message: `Eveniment dezarhivat: ${eventId}`, dryRun: false };
     }
 
-    return { ok: false, action: 'NONE', message: `AcÈ›iune necunoscutÄƒ: ${action}`, raw };
+    const result = { ok: false, action: 'NONE', message: `AcÈ›iune necunoscutÄƒ: ${action}`, raw };
+    const duration = Date.now() - startTime;
+    console.log(`[${requestId}] chatEventOps completed`, {
+      action: result.action,
+      ok: result.ok,
+      durationMs: duration,
+    });
+    return result;
+  } catch (error) {
+    const duration = Date.now() - startTime;
+    console.error(`[${requestId}] chatEventOps error`, {
+      error: error.message,
+      stack: error.stack,
+      durationMs: duration,
+    });
+    throw error;
   }
+}
+
+// Export as onCall handler
+exports.chatEventOps = onCall(
+  { 
+    region: 'us-central1', 
+    timeoutSeconds: 30,
+    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
+  },
+  chatEventOpsHandler
 );
 
+// Export handler function for direct calls (e.g., from chatWithAI)
+exports.chatEventOpsHandler = chatEventOpsHandler;
+
 // Force redeploy Fri Jan  9 14:06:54 UTC 2026
diff --git a/functions/index.js b/functions/index.js
index db7cd048..4ea5b3ca 100644
--- a/functions/index.js
+++ b/functions/index.js
@@ -546,22 +546,38 @@ Scrie "da" pentru a confirma È™i crea evenimentul, sau "anuleazÄƒ" pentru a renu
 
         if (step === 'confirm') {
           if (userText === 'da' || userText === 'confirm' || userText === 'confirma') {
-            // Call chatEventOps to create event
-            const chatEventOps = require('./chatEventOps');
-            
+            // Call chatEventOps via exported callable (proper way)
             const eventText = `NoteazÄƒ eveniment pentru ${eventData.sarbatoritNume}, ${eventData.sarbatoritVarsta} ani, pe ${eventData.date} la ${eventData.address}`;
+            const clientRequestId = `interactive_${currentSessionId}_${Date.now()}`;
+            
+            console.log(`[${requestId}] Creating event via chatEventOps`, {
+              clientRequestId,
+              sessionId: currentSessionId,
+              eventData: {
+                name: eventData.sarbatoritNume,
+                age: eventData.sarbatoritVarsta,
+                date: eventData.date,
+                address: eventData.address,
+              },
+            });
             
             try {
-              const eventResult = await chatEventOps({
+              // Use the exported handler function directly (not the onCall wrapper)
+              const { chatEventOpsHandler } = require('./chatEventOps');
+              
+              // Call handler directly with request-like object
+              const eventResult = await chatEventOpsHandler({
                 data: {
                   text: eventText,
                   dryRun: false,
-                  clientRequestId: `interactive_${currentSessionId}_${Date.now()}`
+                  clientRequestId,
                 },
-                auth: request.auth
-              }, {
-                status: () => ({ json: () => {} }),
-                json: (data) => data
+                auth: request.auth,
+              });
+              
+              console.log(`[${requestId}] Event created successfully`, {
+                eventId: eventResult.eventId,
+                clientRequestId,
               });
               
               // Clear conversation state
@@ -575,7 +591,11 @@ Scrie "da" pentru a confirma È™i crea evenimentul, sau "anuleazÄƒ" pentru a renu
                 eventId: eventResult.eventId
               };
             } catch (error) {
-              console.error(`[${requestId}] Error creating event:`, error);
+              console.error(`[${requestId}] Error creating event:`, {
+                error: error.message,
+                stack: error.stack,
+                clientRequestId,
+              });
               await stateRef.delete();
               
               return {
diff --git a/functions/whatsappProxy.js b/functions/whatsappProxy.js
index f85b42ec..c6481ee6 100644
--- a/functions/whatsappProxy.js
+++ b/functions/whatsappProxy.js
@@ -478,12 +478,16 @@ async function getAccountsHandler(req, res) {
       // Lazy-load Railway base URL (computed at handler runtime, not module load time)
       const railwayBaseUrl = getRailwayBaseUrl();
       if (!railwayBaseUrl) {
+        console.error('[whatsappProxy/getAccounts] WHATSAPP_RAILWAY_BASE_URL missing');
+        console.error('[whatsappProxy/getAccounts] process.env.WHATSAPP_RAILWAY_BASE_URL:', process.env.WHATSAPP_RAILWAY_BASE_URL ? 'SET' : 'NOT SET');
         return res.status(500).json({
           success: false,
           error: 'configuration_missing',
           message: 'WHATSAPP_RAILWAY_BASE_URL must be set via environment variable or functions.config().whatsapp.railway_base_url',
         });
       }
+      
+      console.log('[whatsappProxy/getAccounts] Railway URL:', railwayBaseUrl.substring(0, 30) + '...');
 
       // Forward to Railway backend
       const railwayUrl = `${railwayBaseUrl}/api/whatsapp/accounts`;
@@ -844,6 +848,8 @@ async function regenerateQrHandler(req, res) {
 
       // Forward to Railway backend
       const railwayUrl = `${railwayBaseUrl}/api/whatsapp/regenerate-qr/${accountId.trim()}`;
+      console.log(`[whatsappProxy/regenerateQr] Calling Railway: ${railwayUrl}`);
+      
       const response = await getForwardRequest()(railwayUrl, {
         method: 'POST',
         headers: {
@@ -851,15 +857,35 @@ async function regenerateQrHandler(req, res) {
         },
       });
 
+      console.log(`[whatsappProxy/regenerateQr] Railway response: status=${response.statusCode}, body=${JSON.stringify(response.body).substring(0, 200)}`);
+
       // Forward Railway response, but sanitize non-2xx errors
       if (response.statusCode >= 200 && response.statusCode < 300) {
         return res.status(response.statusCode).json(response.body);
       } else {
-        // Non-2xx: return safe error message
+        // Non-2xx: log full error for debugging
+        console.error(`[whatsappProxy/regenerateQr] Railway error: status=${response.statusCode}, body=${JSON.stringify(response.body)}`);
+        
+        // Special handling for 503 (PASSIVE mode) - propagate error message
+        if (response.statusCode === 503) {
+          return res.status(503).json({
+            success: false,
+            error: response.body?.error || 'backend_unavailable',
+            message: response.body?.message || response.body?.error || 'Backend in PASSIVE mode - lock not acquired',
+            mode: response.body?.mode || 'passive',
+          });
+        }
+        
+        // For other errors, return safe message but include status code
         return res.status(500).json({
           success: false,
           error: 'backend_error',
-          message: 'Backend service returned an error',
+          message: `Backend service returned an error (status: ${response.statusCode})`,
+          // Include Railway error message if available (for debugging)
+          ...(response.body && typeof response.body === 'object' && response.body.error ? {
+            backendError: response.body.error,
+            backendMessage: response.body.message || response.body.error,
+          } : {}),
         });
       }
     } catch (error) {
diff --git a/superparty_flutter/lib/core/errors/app_exception.dart b/superparty_flutter/lib/core/errors/app_exception.dart
index fbd52c96..8c7aa9d3 100644
--- a/superparty_flutter/lib/core/errors/app_exception.dart
+++ b/superparty_flutter/lib/core/errors/app_exception.dart
@@ -38,6 +38,18 @@ class TimeoutException extends AppException {
       : super(message ?? 'Timeout: cererea a durat prea mult.', code: 'timeout');
 }
 
+/// Service unavailable errors (503 - PASSIVE mode, backend down, etc.)
+class ServiceUnavailableException extends AppException {
+  final String? mode; // 'passive' | 'active' | null
+  final String? instanceId;
+  
+  ServiceUnavailableException(
+    super.message, {
+    this.mode,
+    this.instanceId,
+  }) : super(code: 'service_unavailable');
+}
+
 /// Unknown/unexpected errors
 class UnknownException extends AppException {
   UnknownException(super.message, {super.originalError}) : super(code: 'unknown');
@@ -64,12 +76,28 @@ class ErrorMapper {
     return UnknownException(message, originalError: e);
   }
 
-  static AppException fromHttpException(int statusCode, String? message) {
+  static AppException fromHttpException(
+    int statusCode, 
+    String? message, {
+    Map<String, dynamic>? responseBody,
+  }) {
     switch (statusCode) {
       case 401:
         return UnauthorizedException(message);
       case 403:
         return ForbiddenException(message);
+      case 503:
+        // Service unavailable - could be PASSIVE mode
+        final mode = responseBody?['mode'] as String?;
+        final instanceId = responseBody?['instanceId'] as String?;
+        final errorMsg = message ?? 
+                        responseBody?['message'] as String? ?? 
+                        'Serviciul nu este disponibil momentan.';
+        return ServiceUnavailableException(
+          errorMsg,
+          mode: mode,
+          instanceId: instanceId,
+        );
       case 408:
       case 504:
         return TimeoutException(message);
diff --git a/superparty_flutter/lib/core/utils/retry.dart b/superparty_flutter/lib/core/utils/retry.dart
index e6e30a4d..4d9f282b 100644
--- a/superparty_flutter/lib/core/utils/retry.dart
+++ b/superparty_flutter/lib/core/utils/retry.dart
@@ -2,6 +2,8 @@ import 'dart:math';
 import 'package:cloud_functions/cloud_functions.dart';
 import '../errors/app_exception.dart';
 
+// Import ServiceUnavailableException for type check
+
 /// Retry configuration
 class RetryConfig {
   final int maxAttempts;
@@ -30,6 +32,12 @@ class RetryConfig {
       return false; // Never retry auth/permission errors
     }
     
+    // Handle ServiceUnavailableException (503) - retry with longer backoff
+    // PASSIVE mode is transient - backend will retry lock acquisition
+    if (e is ServiceUnavailableException) {
+      return true; // Retry 503 (PASSIVE mode is transient)
+    }
+    
     // Other errors: retry
     return true;
   }
@@ -104,10 +112,21 @@ Future<T> retryWithBackoff<T>(
       }
 
       // Calculate delay with exponential backoff + jitter
-      final exponentialDelay = cfg.initialDelay.inMilliseconds * pow(cfg.backoffMultiplier, attempt - 1);
+      // CRITICAL: For 503 (ServiceUnavailableException), use longer backoff (15s base)
+      // PASSIVE mode requires time for lock acquisition retry
+      final isServiceUnavailable = lastError is ServiceUnavailableException;
+      final baseDelay = isServiceUnavailable 
+          ? const Duration(seconds: 15) // Longer backoff for PASSIVE mode
+          : cfg.initialDelay;
+      
+      final exponentialDelay = baseDelay.inMilliseconds * pow(cfg.backoffMultiplier, attempt - 1);
+      final maxDelayForError = isServiceUnavailable 
+          ? const Duration(seconds: 60) // Max 60s for PASSIVE mode retries
+          : cfg.maxDelay;
+      
       final cappedDelayMs = exponentialDelay.clamp(
-        cfg.initialDelay.inMilliseconds.toDouble(),
-        cfg.maxDelay.inMilliseconds.toDouble(),
+        baseDelay.inMilliseconds.toDouble(),
+        maxDelayForError.inMilliseconds.toDouble(),
       ).toInt();
       
       final jitter = Random().nextInt(cappedDelayMs ~/ 4); // +/- 25% jitter
diff --git a/superparty_flutter/lib/router/app_router.dart b/superparty_flutter/lib/router/app_router.dart
index 08f5e543..0e7d80ad 100644
--- a/superparty_flutter/lib/router/app_router.dart
+++ b/superparty_flutter/lib/router/app_router.dart
@@ -2,7 +2,7 @@ import 'dart:async';
 import 'dart:io';
 import 'dart:convert';
 
-import 'package:flutter/foundation.dart';
+import 'package:flutter/foundation.dart' show kDebugMode;
 import 'package:flutter/material.dart';
 import 'package:go_router/go_router.dart';
 
@@ -17,6 +17,7 @@ import '../screens/disponibilitate/disponibilitate_screen.dart';
 import '../screens/salarizare/salarizare_screen.dart';
 import '../screens/centrala/centrala_screen.dart';
 import '../screens/whatsapp/whatsapp_screen.dart';
+import '../screens/debug/whatsapp_diagnostics_screen.dart';
 import '../screens/whatsapp/whatsapp_accounts_screen.dart';
 import '../screens/whatsapp/whatsapp_inbox_screen.dart';
 import '../screens/whatsapp/whatsapp_chat_screen.dart';
@@ -116,6 +117,12 @@ class AppRouter {
           child: const WhatsAppScreen(),
         ),
         routes: [
+          // Debug diagnostics (only in debug mode)
+          if (kDebugMode)
+            GoRoute(
+              path: 'diagnostics',
+              builder: (context, state) => const WhatsAppDiagnosticsScreen(),
+            ),
           GoRoute(
             path: 'accounts',
             builder: (context, state) => AuthGate(
diff --git a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
index 58e367f6..86e30e71 100644
--- a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
+++ b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
@@ -372,6 +372,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         // Generate unique clientRequestId for idempotency
         final clientRequestId = 'req_${DateTime.now().millisecondsSinceEpoch}_${Random().nextInt(9999)}';
         
+        debugPrint('[AIChat] Calling chatEventOps (preview): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=true');
+        
         // Call chatEventOps with dryRun=true for preview
         final eventCallable =
             FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -385,6 +387,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
           'clientRequestId': clientRequestId,
         });
         
+        debugPrint('[AIChat] chatEventOps preview result: requestId=$clientRequestId, ok=${previewResult.data['ok']}, action=${previewResult.data['action']}');
+        
         final previewData = Map<String, dynamic>.from(previewResult.data);
         
         // Remove placeholder and show preview
@@ -1308,6 +1312,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
     });
     _scrollToBottomSoon();
 
+    debugPrint('[AIChat] Calling chatEventOps (create): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=false');
+    
     try {
       final eventCallable =
           FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -1320,6 +1326,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         'dryRun': false,
         'clientRequestId': clientRequestId,
       });
+      
+      debugPrint('[AIChat] chatEventOps create result: requestId=$clientRequestId, ok=${result.data['ok']}, action=${result.data['action']}, eventId=${result.data['eventId']}');
 
       final data = Map<String, dynamic>.from(result.data);
       final ok = data['ok'] == true;
diff --git a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
index 4501cfc3..fda58f39 100644
--- a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
+++ b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
@@ -2,6 +2,7 @@ import 'dart:ui' show ImageFilter;
 import 'dart:io';
 import 'dart:convert';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:cloud_firestore/cloud_firestore.dart';
 import '../../models/event_model.dart';
 import '../../widgets/modals/range_modal.dart';
@@ -512,6 +513,7 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         }
 
         if (snapshot.hasError) {
+          debugPrint('[EvenimenteScreen] Firestore error: ${snapshot.error}');
           return Center(
             child: Text(
               'Eroare: ${snapshot.error}',
@@ -523,17 +525,54 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         final events = snapshot.data?.docs.map((doc) {
           return EventModel.fromFirestore(doc);
         }).toList() ?? [];
+        
+        debugPrint('[EvenimenteScreen] Loaded ${events.length} events from Firestore');
+        debugPrint('[EvenimenteScreen] Events with isArchived=false: ${events.where((e) => !e.isArchived).length}');
+        
         _allEvents = events; // Cache for CodeInfoModal
         final filteredEvents = _applyFilters(events);
+        
+        debugPrint('[EvenimenteScreen] Filtered events count: ${filteredEvents.length}');
 
         if (filteredEvents.isEmpty) {
           return Center(
-            child: Text(
-              'Nu existÄƒ evenimente',
-              style: TextStyle(
-                fontSize: 14,
-                color: const Color(0xFFEAF1FF).withValues(alpha: 0.7),
-              ),
+            child: Column(
+              mainAxisAlignment: MainAxisAlignment.center,
+              children: [
+                Icon(
+                  Icons.event_busy,
+                  size: 64,
+                  color: const Color(0xFFEAF1FF).withValues(alpha: 0.5),
+                ),
+                const SizedBox(height: 16),
+                Text(
+                  'Nu existÄƒ evenimente',
+                  style: TextStyle(
+                    fontSize: 16,
+                    color: const Color(0xFFEAF1FF).withValues(alpha: 0.7),
+                  ),
+                ),
+                const SizedBox(height: 8),
+                Text(
+                  'Total Ã®n Firestore: ${events.length} (arhivate: ${events.where((e) => e.isArchived).length})',
+                  style: TextStyle(
+                    fontSize: 12,
+                    color: const Color(0xFFEAF1FF).withValues(alpha: 0.5),
+                  ),
+                ),
+                if (events.isEmpty) ...[
+                  const SizedBox(height: 16),
+                  Text(
+                    'ðŸ’¡ CreeazÄƒ evenimente din AI Chat sau foloseÈ™te seed_evenimente.js',
+                    style: TextStyle(
+                      fontSize: 12,
+                      color: const Color(0xFFEAF1FF).withValues(alpha: 0.5),
+                      fontStyle: FontStyle.italic,
+                    ),
+                    textAlign: TextAlign.center,
+                  ),
+                ],
+              ],
             ),
           );
         }
diff --git a/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart b/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
index 5f83fff1..1bcbc86f 100644
--- a/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
+++ b/superparty_flutter/lib/screens/whatsapp/whatsapp_accounts_screen.dart
@@ -1,8 +1,10 @@
 import 'dart:convert';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:qr_flutter/qr_flutter.dart';
 import 'package:url_launcher/url_launcher.dart';
 import '../../services/whatsapp_api_service.dart';
+import '../../core/errors/app_exception.dart';
 
 /// WhatsApp Accounts Management Screen
 /// 
@@ -30,25 +32,42 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
   @override
   void initState() {
     super.initState();
+    debugPrint('[WhatsAppAccountsScreen] initState: loading accounts');
     _loadAccounts();
   }
 
   Future<void> _loadAccounts() async {
     final myToken = ++_loadRequestToken;
     
+    debugPrint('[WhatsAppAccountsScreen] _loadAccounts: starting (token=$myToken)');
+    
     setState(() {
       _isLoading = true;
       _error = null;
     });
 
     try {
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: calling getAccounts()');
       final response = await _apiService.getAccounts();
       
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: response received (token=$myToken, success=${response['success']}, accountsCount=${(response['accounts'] as List?)?.length ?? 0})');
+      
       // Ignore late responses (if another load started)
-      if (myToken != _loadRequestToken) return;
+      if (myToken != _loadRequestToken) {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: ignoring late response (token mismatch)');
+        return;
+      }
       
       if (response['success'] == true) {
         final accounts = response['accounts'] as List<dynamic>? ?? [];
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: success, ${accounts.length} accounts');
+        
+        // Log account statuses for debugging
+        for (final account in accounts) {
+          final acc = account as Map<String, dynamic>;
+          debugPrint('[WhatsAppAccountsScreen] Account: id=${acc['id']}, status=${acc['status']}, hasQR=${acc['qrCode'] != null}');
+        }
+        
         if (mounted && myToken == _loadRequestToken) {
           setState(() {
             _accounts = accounts.cast<Map<String, dynamic>>();
@@ -56,6 +75,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
           });
         }
       } else {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: failed - ${response['message']}');
         if (mounted && myToken == _loadRequestToken) {
           setState(() {
             _error = response['message'] ?? 'Failed to load accounts';
@@ -64,12 +84,25 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         }
       }
     } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _loadAccounts: exception - $e');
       // Ignore late responses
-      if (myToken != _loadRequestToken) return;
+      if (myToken != _loadRequestToken) {
+        debugPrint('[WhatsAppAccountsScreen] _loadAccounts: ignoring late exception (token mismatch)');
+        return;
+      }
       
       if (mounted) {
+        String errorMessage = 'Error: ${e.toString()}';
+        
+        // Special handling for ServiceUnavailableException (503 - PASSIVE mode)
+        if (e is ServiceUnavailableException) {
+          errorMessage = e.mode == 'passive'
+              ? 'Backend Ã®n mod PASSIVE (lock nu este achiziÈ›ionat). ReÃ®ncearcÄƒ Ã®n cÃ¢teva secunde.'
+              : e.message;
+        }
+        
         setState(() {
-          _error = 'Error: ${e.toString()}';
+          _error = errorMessage;
           _isLoading = false;
         });
       }
@@ -122,10 +155,18 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
       ),
     );
 
-    if (result != true) return;
+    if (result != true) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: cancelled');
+      return;
+    }
 
     // Guard: prevent double-tap
-    if (_isAddingAccount) return;
+    if (_isAddingAccount) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: already in progress, skipping');
+      return;
+    }
+    
+    debugPrint('[WhatsAppAccountsScreen] _addAccount: starting (name=${nameController.text.trim()}, phone=${phoneController.text.trim()})');
     setState(() => _isAddingAccount = true);
 
     try {
@@ -134,6 +175,8 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         phone: phoneController.text.trim(),
       );
 
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: response received (success=${response['success']}, accountId=${response['account']?['id'] ?? response['accountId']})');
+
       if (mounted) {
         if (response['success'] == true) {
           ScaffoldMessenger.of(context).showSnackBar(
@@ -142,8 +185,10 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
               backgroundColor: Colors.green,
             ),
           );
+          debugPrint('[WhatsAppAccountsScreen] _addAccount: success, reloading accounts');
           await _loadAccounts();
         } else {
+          debugPrint('[WhatsAppAccountsScreen] _addAccount: failed - ${response['message']}');
           ScaffoldMessenger.of(context).showSnackBar(
             SnackBar(
               content: Text(response['message'] ?? 'Failed to add account'),
@@ -153,11 +198,24 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         }
       }
     } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _addAccount: exception - $e');
       if (mounted) {
+        String errorMessage = 'Error: ${e.toString()}';
+        Color backgroundColor = Colors.red;
+        
+        // Special handling for ServiceUnavailableException (503 - PASSIVE mode)
+        if (e is ServiceUnavailableException) {
+          errorMessage = e.mode == 'passive'
+              ? 'Backend Ã®n mod PASSIVE. Lock nu este achiziÈ›ionat. ReÃ®ncearcÄƒ Ã®n cÃ¢teva secunde.'
+              : e.message;
+          backgroundColor = Colors.purple; // Purple for PASSIVE mode
+        }
+        
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(
-            content: Text('Error: ${e.toString()}'),
-            backgroundColor: Colors.red,
+            content: Text(errorMessage),
+            backgroundColor: backgroundColor,
+            duration: const Duration(seconds: 5),
           ),
         );
       }
@@ -170,13 +228,19 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
 
   Future<void> _regenerateQr(String accountId) async {
     // Guard: prevent double-tap
-    if (_regeneratingQr.contains(accountId)) return;
+    if (_regeneratingQr.contains(accountId)) {
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: already in progress for $accountId');
+      return;
+    }
     
+    debugPrint('[WhatsAppAccountsScreen] _regenerateQr: starting for accountId=$accountId');
     setState(() => _regeneratingQr.add(accountId));
 
     try {
       final response = await _apiService.regenerateQr(accountId: accountId);
 
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: response received (success=${response['success']}, message=${response['message']}, error=${response['error']}, mode=${response['mode']})');
+
       if (mounted) {
         if (response['success'] == true) {
           ScaffoldMessenger.of(context).showSnackBar(
@@ -186,18 +250,51 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
             ),
           );
           // Reload accounts to get new QR code
+          debugPrint('[WhatsAppAccountsScreen] _regenerateQr: waiting 2s then reloading accounts');
           await Future.delayed(const Duration(seconds: 2));
           await _loadAccounts();
         } else {
+          final errorMessage = response['message'] ?? response['backendMessage'] ?? 'Failed to regenerate QR';
+          final errorMode = response['mode'];
+          final backendError = response['error'] ?? response['backendError'];
+          
+          debugPrint('[WhatsAppAccountsScreen] _regenerateQr: failed - $errorMessage (error=$backendError, mode=$errorMode)');
+          
+          // Special handling for PASSIVE mode
+          if (errorMode == 'passive' || backendError == 'PASSIVE mode') {
+            ScaffoldMessenger.of(context).showSnackBar(
+              SnackBar(
+                content: Text('Backend in PASSIVE mode: ${response['message'] ?? 'Lock not acquired. Retry shortly.'}'),
+                backgroundColor: Colors.purple,
+                duration: const Duration(seconds: 5),
+              ),
+            );
+          } else {
+            ScaffoldMessenger.of(context).showSnackBar(
+              SnackBar(
+                content: Text(errorMessage),
+                backgroundColor: Colors.red,
+              ),
+            );
+          }
+        }
+      }
+    } catch (e) {
+      debugPrint('[WhatsAppAccountsScreen] _regenerateQr: exception - $e');
+      
+      // Special handling for ServiceUnavailableException (503 - PASSIVE mode)
+      if (e is ServiceUnavailableException && e.mode == 'passive') {
+        if (mounted) {
           ScaffoldMessenger.of(context).showSnackBar(
             SnackBar(
-              content: Text(response['message'] ?? 'Failed to regenerate QR'),
-              backgroundColor: Colors.red,
+              content: Text('Backend Ã®n mod PASSIVE. Lock nu este achiziÈ›ionat. ReÃ®ncearcÄƒ Ã®n cÃ¢teva secunde.'),
+              backgroundColor: Colors.purple,
+              duration: const Duration(seconds: 5),
             ),
           );
         }
+        return; // Don't show generic error for PASSIVE mode
       }
-    } catch (e) {
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(
@@ -288,11 +385,16 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
     final status = account['status'] as String? ?? 'unknown';
     final qrCode = account['qrCode'] as String?;
     final pairingCode = account['pairingCode'] as String?;
+    final lastError = account['lastError'] as String?;
+    final passiveModeReason = account['passiveModeReason'] as String?;
 
     final statusColor = _getStatusColor(status);
     final showQr = status == 'qr_ready' && qrCode != null;
     // When showQr is true, qrCode is guaranteed non-null
     final qrCodeData = qrCode ?? '';
+    
+    // Show passive mode warning if status is passive
+    final isPassive = status == 'passive' || passiveModeReason != null;
 
     return Card(
       margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
@@ -335,7 +437,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                     border: Border.all(color: statusColor),
                   ),
                   child: Text(
-                    status.toUpperCase(),
+                    _getStatusDisplayText(status),
                     style: TextStyle(
                       fontSize: 12,
                       fontWeight: FontWeight.bold,
@@ -345,6 +447,53 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                 ),
               ],
             ),
+            if (isPassive) ...[
+              const SizedBox(height: 12),
+              Container(
+                padding: const EdgeInsets.all(12),
+                decoration: BoxDecoration(
+                  color: Colors.purple.withValues(alpha: 0.1),
+                  borderRadius: BorderRadius.circular(8),
+                  border: Border.all(color: Colors.purple),
+                ),
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Row(
+                      children: [
+                        const Icon(Icons.warning_amber_rounded, color: Colors.purple, size: 20),
+                        const SizedBox(width: 8),
+                        const Text(
+                          'Backend in PASSIVE mode',
+                          style: TextStyle(
+                            fontSize: 14,
+                            fontWeight: FontWeight.bold,
+                            color: Colors.purple,
+                          ),
+                        ),
+                      ],
+                    ),
+                    const SizedBox(height: 4),
+                    Text(
+                      passiveModeReason ?? lastError ?? 'Lock not acquired by this instance',
+                      style: const TextStyle(
+                        fontSize: 12,
+                        color: Colors.purple,
+                      ),
+                    ),
+                    const SizedBox(height: 4),
+                    const Text(
+                      'Backend will retry lock acquisition automatically. Accounts cannot connect until backend is ACTIVE.',
+                      style: TextStyle(
+                        fontSize: 11,
+                        color: Colors.purple,
+                        fontStyle: FontStyle.italic,
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+            ],
             if (showQr) ...[
               const SizedBox(height: 16),
               Center(
@@ -463,10 +612,25 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
         return Colors.blue;
       case 'disconnected':
         return Colors.red;
+      case 'passive':
+        return Colors.purple; // Purple for passive mode
+      case 'needs_qr':
+        return Colors.amber;
       default:
         return Colors.grey;
     }
   }
+  
+  String _getStatusDisplayText(String status) {
+    switch (status.toLowerCase()) {
+      case 'passive':
+        return 'PASSIVE (Backend not active)';
+      case 'needs_qr':
+        return 'NEEDS QR';
+      default:
+        return status.toUpperCase();
+    }
+  }
 
   @override
   Widget build(BuildContext context) {
@@ -485,7 +649,7 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
       ),
       body: _isLoading
           ? const Center(child: CircularProgressIndicator())
-          : _error != null
+              : _error != null
               ? Center(
                   child: Padding(
                     padding: const EdgeInsets.all(24.0),
@@ -493,9 +657,9 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                       mainAxisAlignment: MainAxisAlignment.center,
                       children: [
                         Icon(
-                          Icons.error_outline,
+                          _error!.contains('PASSIVE') ? Icons.pause_circle_outline : Icons.error_outline,
                           size: 64,
-                          color: Colors.red[300],
+                          color: _error!.contains('PASSIVE') ? Colors.purple[300] : Colors.red[300],
                         ),
                         const SizedBox(height: 16),
                         Text(
@@ -503,6 +667,14 @@ class _WhatsAppAccountsScreenState extends State<WhatsAppAccountsScreen> {
                           style: const TextStyle(fontSize: 16),
                           textAlign: TextAlign.center,
                         ),
+                        if (_error!.contains('PASSIVE')) ...[
+                          const SizedBox(height: 8),
+                          const Text(
+                            'Backend-ul va Ã®ncerca automat sÄƒ achiziÈ›ioneze lock-ul.',
+                            style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic),
+                            textAlign: TextAlign.center,
+                          ),
+                        ],
                         const SizedBox(height: 24),
                         ElevatedButton(
                           onPressed: _loadAccounts,
diff --git a/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart b/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
index 113179c6..71b0e87b 100644
--- a/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
+++ b/superparty_flutter/lib/screens/whatsapp/whatsapp_chat_screen.dart
@@ -1,6 +1,7 @@
 import 'package:cloud_firestore/cloud_firestore.dart';
 import 'package:firebase_auth/firebase_auth.dart';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:go_router/go_router.dart';
 import 'package:intl/intl.dart';
 
@@ -53,9 +54,12 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
   Future<void> _sendMessage() async {
     final text = _messageController.text.trim();
     if (text.isEmpty || _isSending || _accountId == null || _threadId == null || _clientJid == null) {
+      debugPrint('[WhatsAppChatScreen] _sendMessage: validation failed (isEmpty=${text.isEmpty}, isSending=$_isSending, accountId=$_accountId, threadId=$_threadId, clientJid=$_clientJid)');
       return;
     }
 
+    debugPrint('[WhatsAppChatScreen] _sendMessage: starting (accountId=$_accountId, threadId=$_threadId, textLength=${text.length})');
+    
     setState(() {
       _isSending = true;
     });
@@ -63,7 +67,9 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
     try {
       final clientMessageId = 'client_${DateTime.now().millisecondsSinceEpoch}';
       
-      await _apiService.sendViaProxy(
+      debugPrint('[WhatsAppChatScreen] _sendMessage: calling sendViaProxy (clientMessageId=$clientMessageId)');
+      
+      final result = await _apiService.sendViaProxy(
         threadId: _threadId!,
         accountId: _accountId!,
         toJid: _clientJid!,
@@ -71,11 +77,14 @@ class _WhatsAppChatScreenState extends State<WhatsAppChatScreen> {
         clientMessageId: clientMessageId,
       );
 
+      debugPrint('[WhatsAppChatScreen] _sendMessage: success (requestId=${result['requestId']}, duplicate=${result['duplicate']})');
+
       if (mounted) {
         _messageController.clear();
         _scrollToBottom();
       }
     } catch (e) {
+      debugPrint('[WhatsAppChatScreen] _sendMessage: exception - $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('Error sending message: $e')),
diff --git a/superparty_flutter/lib/services/whatsapp_api_service.dart b/superparty_flutter/lib/services/whatsapp_api_service.dart
index cb8d90a5..5feb13be 100644
--- a/superparty_flutter/lib/services/whatsapp_api_service.dart
+++ b/superparty_flutter/lib/services/whatsapp_api_service.dart
@@ -81,10 +81,21 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
+      final endpointUrl = '$functionsUrl/whatsappProxySend';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] sendViaProxy: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  threadId: $threadId, accountId: $accountId, toJid: $toJid');
+      debugPrint('  textLength: ${text.length}');
+
       // Call Functions proxy with timeout
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxySend'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -100,8 +111,13 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
+      debugPrint('[WhatsAppApiService] sendViaProxy: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
+
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
+        debugPrint('[WhatsAppApiService] sendViaProxy: error=${errorBody?['error']}, message=${errorBody?['message']}');
         throw ErrorMapper.fromHttpException(
           response.statusCode,
           errorBody?['message'] as String?,
@@ -109,6 +125,7 @@ class WhatsAppApiService {
       }
 
       final data = jsonDecode(response.body) as Map<String, dynamic>;
+      debugPrint('[WhatsAppApiService] sendViaProxy: success (requestId=${data['requestId']}, duplicate=${data['duplicate']})');
       return data;
     });
   }
@@ -132,12 +149,19 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] getAccounts: calling proxy (uid=${user.uid.substring(0, 8)}...)');
+      final endpointUrl = '$functionsUrl/whatsappProxyGetAccounts';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] getAccounts: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .get(
-            Uri.parse('$functionsUrl/whatsappProxyGetAccounts'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -146,14 +170,17 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] getAccounts: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] getAccounts: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
-        debugPrint('[WhatsAppApiService] getAccounts: error=${errorBody?['error']}, message=${errorBody?['message']}');
+        debugPrint('[WhatsAppApiService] getAccounts: error=${errorBody?['error']}, message=${errorBody?['message']}, mode=${errorBody?['mode']}, instanceId=${errorBody?['instanceId']}');
         throw ErrorMapper.fromHttpException(
           response.statusCode,
           errorBody?['message'] as String?,
+          responseBody: errorBody,
         );
       }
 
@@ -186,12 +213,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] addAccount: calling proxy (uid=${user.uid.substring(0, 8)}..., name=$name, phone=$phone)');
+      final endpointUrl = '$functionsUrl/whatsappProxyAddAccount';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] addAccount: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  name: $name, phone: $phone');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyAddAccount'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -204,14 +239,17 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] addAccount: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] addAccount: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
-        debugPrint('[WhatsAppApiService] addAccount: error=${errorBody?['error']}, message=${errorBody?['message']}');
+        debugPrint('[WhatsAppApiService] addAccount: error=${errorBody?['error']}, message=${errorBody?['message']}, mode=${errorBody?['mode']}, instanceId=${errorBody?['instanceId']}');
         throw ErrorMapper.fromHttpException(
           response.statusCode,
           errorBody?['message'] as String?,
+          responseBody: errorBody,
         );
       }
 
@@ -241,12 +279,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy (uid=${user.uid.substring(0, 8)}..., accountId=$accountId)');
+      final endpointUrl = '$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  accountId: $accountId');
 
       // Call Functions proxy with Authorization header (query param for accountId)
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -255,14 +301,17 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] regenerateQr: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] regenerateQr: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
-        debugPrint('[WhatsAppApiService] regenerateQr: error=${errorBody?['error']}, message=${errorBody?['message']}');
+        debugPrint('[WhatsAppApiService] regenerateQr: error=${errorBody?['error']}, message=${errorBody?['message']}, mode=${errorBody?['mode']}, instanceId=${errorBody?['instanceId']}');
         throw ErrorMapper.fromHttpException(
           response.statusCode,
           errorBody?['message'] as String?,
+          responseBody: errorBody,
         );
       }
 
diff --git a/whatsapp-backend/lib/wa-bootstrap.js b/whatsapp-backend/lib/wa-bootstrap.js
index 34052aa9..e5fe8484 100644
--- a/whatsapp-backend/lib/wa-bootstrap.js
+++ b/whatsapp-backend/lib/wa-bootstrap.js
@@ -132,26 +132,48 @@ function stopPassiveRetryLoop() {
  */
 function setupLockLostHandler() {
   // Check lock status every 30s
-  setInterval(async () => {
-    if (!waIntegration || !isActive) return;
+  const lockCheckInterval = setInterval(async () => {
+    if (!waIntegration || !isActive) {
+      // If not active, stop checking (will be restarted when active)
+      clearInterval(lockCheckInterval);
+      return;
+    }
 
-    const lockStatus = await waIntegration.stability.lock.getStatus();
+    try {
+      const lockStatus = await waIntegration.stability.lock.getStatus();
 
-    if (!lockStatus.isHolder) {
-      console.error('[WABootstrap] ðŸš¨ LOCK LOST - entering PASSIVE mode');
-      console.error(
-        `[WABootstrap] lock_lost_entering_passive instanceId=${instanceId} leaseEpoch=${lockStatus.leaseEpoch || 'unknown'}`
-      );
+      if (!lockStatus.isHolder) {
+        console.error('[WABootstrap] ðŸš¨ LOCK LOST - entering PASSIVE mode');
+        console.error(
+          `[WABootstrap] lock_lost_entering_passive instanceId=${instanceId} leaseEpoch=${lockStatus.leaseEpoch || 'unknown'} holderInstanceId=${lockStatus.holderInstanceId || 'unknown'}`
+        );
 
-      isActive = false;
+        isActive = false;
+        clearInterval(lockCheckInterval); // Stop checking when passive
 
-      // TODO: Close all Baileys sockets immediately
-      // This will be implemented when integrating with actual socket management
+        // TODO: Close all Baileys sockets immediately
+        // This will be implemented when integrating with actual socket management
 
-      console.log('[WABootstrap] All Baileys connections closed');
-      console.log('[WABootstrap] Now in PASSIVE mode');
+        console.log('[WABootstrap] All Baileys connections closed');
+        console.log('[WABootstrap] Now in PASSIVE mode - will retry lock acquisition');
+        
+        // Restart passive retry loop to re-acquire lock
+        if (waIntegration && db) {
+          startPassiveRetryLoop(db);
+        }
+      } else {
+        // Lock still held - log periodically for debugging
+        if (Date.now() % 300000 < 30000) { // Log every ~5 minutes
+          console.log(`[WABootstrap] Lock check: still holder (leaseEpoch: ${lockStatus.leaseEpoch || 'unknown'})`);
+        }
+      }
+    } catch (error) {
+      console.error('[WABootstrap] Lock status check failed:', error.message);
+      // Continue checking on next interval
     }
   }, 30000);
+  
+  console.log('[WABootstrap] Lock lost handler started (checks every 30s)');
 }
 
 /**
diff --git a/whatsapp-backend/server.js b/whatsapp-backend/server.js
index 0ae451ce..9c30ed62 100644
--- a/whatsapp-backend/server.js
+++ b/whatsapp-backend/server.js
@@ -1008,7 +1008,17 @@ function isTerminalLogout(reasonCode) {
 async function createConnection(accountId, name, phone) {
   // HARD GATE: PASSIVE mode - do NOT start Baileys connections
   if (!waBootstrap.canStartBaileys()) {
+    const status = await waBootstrap.getWAStatus();
     console.log(`â¸ï¸  [${accountId}] PASSIVE mode - cannot start Baileys connection (lock not held)`);
+    console.log(`â¸ï¸  [${accountId}] PASSIVE mode details: reason=${status.reason || 'unknown'}, instanceId=${status.instanceId || 'unknown'}`);
+    
+    // Save passive status to Firestore so Flutter can display it
+    await saveAccountToFirestore(accountId, {
+      status: 'passive',
+      lastError: `Backend in PASSIVE mode: ${status.reason || 'lock not acquired'}`,
+      passiveModeReason: status.reason || 'lock_not_acquired',
+    }).catch(err => console.error(`âŒ [${accountId}] Failed to save passive status:`, err));
+    
     return;
   }
 
@@ -1123,11 +1133,22 @@ async function createConnection(accountId, name, phone) {
     console.log(`ðŸ”Œ [${accountId}] Connection session #${currentSessionId} started`);
 
     // Set timeout to prevent "connecting forever" (configurable via env)
+    // CRITICAL: Only apply timeout for normal connecting, NOT for pairing phase (qr_ready/awaiting_scan)
+    // Pairing phase uses QR_SCAN_TIMEOUT (10 minutes) instead
     const CONNECTING_TIMEOUT = parseInt(process.env.WHATSAPP_CONNECT_TIMEOUT_MS || '60000', 10);
     account.connectingTimeout = setTimeout(() => {
       const timeoutSeconds = Math.floor(CONNECTING_TIMEOUT / 1000);
-      console.log(`â° [${accountId}] Connecting timeout (${timeoutSeconds}s), transitioning to disconnected`);
       const acc = connections.get(accountId);
+      
+      // CRITICAL FIX: Don't timeout if status is pairing phase (qr_ready, awaiting_scan, pairing)
+      // These states use QR_SCAN_TIMEOUT instead (10 minutes)
+      const isPairingPhase = acc && ['qr_ready', 'awaiting_scan', 'pairing'].includes(acc.status);
+      if (isPairingPhase) {
+        console.log(`â° [${accountId}] Connecting timeout skipped (status: ${acc.status} - pairing phase uses QR_SCAN_TIMEOUT)`);
+        return; // Don't timeout pairing phase
+      }
+      
+      console.log(`â° [${accountId}] Connecting timeout (${timeoutSeconds}s), transitioning to disconnected`);
       if (acc && acc.status === 'connecting') {
         acc.status = 'disconnected';
         acc.lastError = 'Connection timeout - no progress after 60s';
@@ -1227,18 +1248,19 @@ async function createConnection(accountId, name, phone) {
 
           console.log(`âœ… [${accountId}] QR saved to Firestore`);
 
-          // Invalidate accounts cache so frontend gets updated QR
-          if (featureFlags.isEnabled('API_CACHING')) {
-            await cache.delete('whatsapp:accounts');
-            console.log(`ðŸ—‘ï¸  [${accountId}] Cache invalidated for QR update`);
-          }
+    // Invalidate accounts cache so frontend gets updated QR
+    if (featureFlags.isEnabled('API_CACHING')) {
+      await cache.delete('whatsapp:accounts');
+      console.log(`ðŸ—‘ï¸  [${accountId}] Cache invalidated for QR update`);
+    }
 
-          logger.info('QR code generated and saved', { accountId, qrLength: qr.length });
-          logtail.info('QR code generated', {
-            accountId,
-            qrLength: qr.length,
-            phone: maskPhone(phone),
-          });
+    logger.info('QR code generated and saved', { accountId, qrLength: qr.length });
+    logtail.info('QR code generated', {
+      accountId,
+      qrLength: qr.length,
+      phone: maskPhone(phone),
+      instanceId: process.env.RAILWAY_DEPLOYMENT_ID || 'local',
+    });
         } catch (error) {
           console.error(`âŒ [${accountId}] QR generation failed:`, error.message);
           logger.error('QR generation failed', { accountId, error: error.message });
@@ -1336,13 +1358,26 @@ async function createConnection(accountId, name, phone) {
         const rawReason = boomStatus ?? errorCode ?? 'unknown';
         
         // Normalize reason to number for comparison
-        const reason = typeof rawReason === 'number' ? rawReason : (typeof rawReason === 'string' ? parseInt(rawReason, 10) || 'unknown' : 'unknown');
+        // CRITICAL: Handle 515 (restart required) explicitly
+        let reason = typeof rawReason === 'number' ? rawReason : (typeof rawReason === 'string' ? parseInt(rawReason, 10) || 'unknown' : 'unknown');
+        
+        // CRITICAL: If error message contains "restart required" but statusCode is not 515, set it
+        if (error?.message && error.message.includes('restart required') && reason !== 515) {
+          console.log(`ðŸ” [${accountId}] Detected "restart required" in message but statusCode is ${reason}, normalizing to 515`);
+          reason = 515;
+        }
         
         // Extract Boom error details for better logging
         const boomPayload = error?.output?.payload;
         const errorMessage = error?.message || 'No error message';
         const errorStack = error?.stack;
         
+        // CRITICAL: Detect reason code 515 (restart required) - common in pairing phase
+        // 515 = "Stream Errored (restart required)" - requires socket recreation + new QR
+        const isRestartRequired = (typeof reason === 'number' && reason === 515) || 
+                                 (typeof boomStatus === 'number' && boomStatus === 515) ||
+                                 (errorMessage && errorMessage.includes('restart required'));
+        
         // Log detailed disconnect information (helps diagnose "unknown" reasons)
         console.error(`ðŸ”Œ [${accountId}] connection.update: close`, {
           sessionId: account.sessionId || 'unknown', // Connection session ID for debugging
@@ -1356,6 +1391,7 @@ async function createConnection(accountId, name, phone) {
           shouldReconnect: reason !== DisconnectReason.loggedOut,
           currentStatus: account.status,
           isPairingPhase: ['qr_ready', 'awaiting_scan', 'pairing', 'connecting'].includes(account.status),
+          isRestartRequired: isRestartRequired, // CRITICAL: Flag for 515 handling
           lastDisconnect: lastDisconnect ? {
             error: error ? {
               name: error.name,
@@ -1369,7 +1405,9 @@ async function createConnection(accountId, name, phone) {
           } : undefined,
         });
         
-        const shouldReconnect = reason !== DisconnectReason.loggedOut;
+        // CRITICAL FIX: For 515 (restart required), always reconnect (even in pairing phase)
+        // 515 means stream errored but session is valid - need new socket + potentially new QR
+        const shouldReconnect = reason !== DisconnectReason.loggedOut || isRestartRequired;
 
         // Define explicit cleanup reasons (only these trigger account deletion)
         // Ensure we compare numbers consistently
@@ -1451,23 +1489,43 @@ async function createConnection(accountId, name, phone) {
           // CRITICAL FIX: Auto-reconnect in pairing phase for transient errors
           // Don't leave account stuck in qr_ready if socket closes due to transient network issue
           // Only skip reconnect if reason is terminal (loggedOut/badSession/unauthorized)
-          if (shouldReconnect && reason !== DisconnectReason.loggedOut) {
+          // SPECIAL HANDLING: 515 (restart required) always triggers reconnect + QR regeneration
+          if (shouldReconnect && (reason !== DisconnectReason.loggedOut || isRestartRequired)) {
             const attempts = reconnectAttempts.get(accountId) || 0;
             const MAX_PAIRING_RECONNECT_ATTEMPTS = parseInt(process.env.MAX_PAIRING_RECONNECT_ATTEMPTS || '10', 10);
             
+            // CRITICAL: For 515, clear QR immediately (will be regenerated on reconnect)
+            if (isRestartRequired) {
+              console.log(`ðŸ”„ [${accountId}] Reason 515 (restart required) - clearing QR, will regenerate on reconnect`);
+              account.qrCode = null;
+              account.status = 'connecting'; // Reset to connecting to trigger new QR generation
+              await saveAccountToFirestore(accountId, {
+                qrCode: null,
+                status: 'connecting',
+                lastDisconnectReason: 'restart_required_515',
+                lastDisconnectCode: 515,
+              });
+            }
+            
             if (attempts < MAX_PAIRING_RECONNECT_ATTEMPTS) {
               // Exponential backoff for pairing phase: 1s, 2s, 4s, 8s, 16s, 30s (max)
-              const backoff = Math.min(1000 * Math.pow(2, attempts), 30000);
+              // For 515, use shorter backoff (2s, 4s, 8s) since it's a known recoverable error
+              const baseBackoff = isRestartRequired ? 2000 : 1000;
+              const backoff = Math.min(baseBackoff * Math.pow(2, attempts), 30000);
               console.log(
-                `ðŸ”„ [${accountId}] Pairing phase reconnect in ${backoff}ms (attempt ${attempts + 1}/${MAX_PAIRING_RECONNECT_ATTEMPTS}, reason: ${reason})`
+                `ðŸ”„ [${accountId}] Pairing phase reconnect in ${backoff}ms (attempt ${attempts + 1}/${MAX_PAIRING_RECONNECT_ATTEMPTS}, reason: ${reason}${isRestartRequired ? ' [515 restart required]' : ''})`
               );
               
               reconnectAttempts.set(accountId, attempts + 1);
               
               setTimeout(() => {
                 const acc = connections.get(accountId);
-                if (acc && ['qr_ready', 'awaiting_scan', 'connecting'].includes(acc.status)) {
-                  console.log(`ðŸ”„ [${accountId}] Starting pairing phase reconnect (session will be new)`);
+                if (acc && ['qr_ready', 'awaiting_scan', 'connecting', 'needs_qr'].includes(acc.status)) {
+                  console.log(`ðŸ”„ [${accountId}] Starting pairing phase reconnect (session will be new${isRestartRequired ? ', QR will be regenerated' : ''})`);
+                  // Reset status to connecting to ensure fresh QR generation
+                  if (isRestartRequired) {
+                    acc.status = 'connecting';
+                  }
                   createConnection(accountId, acc.name, acc.phone);
                 }
               }, backoff);
@@ -1476,12 +1534,12 @@ async function createConnection(accountId, name, phone) {
               account.status = 'needs_qr';
               await saveAccountToFirestore(accountId, {
                 status: 'needs_qr',
-                lastError: `Max pairing reconnect attempts (${MAX_PAIRING_RECONNECT_ATTEMPTS}) reached`,
+                lastError: `Max pairing reconnect attempts (${MAX_PAIRING_RECONNECT_ATTEMPTS}) reached${isRestartRequired ? ' (reason: 515 restart required)' : ''}`,
               });
               reconnectAttempts.delete(accountId);
             }
           } else {
-            console.log(`â¸ï¸  [${accountId}] Pairing phase close: no reconnect (reason: ${reason}, shouldReconnect: ${shouldReconnect})`);
+            console.log(`â¸ï¸  [${accountId}] Pairing phase close: no reconnect (reason: ${reason}, shouldReconnect: ${shouldReconnect}, isRestartRequired: ${isRestartRequired})`);
           }
           
           return;
@@ -1941,6 +1999,44 @@ app.get('/health', (req, res) => {
   });
 });
 
+// /api/longrun/status-now endpoint - comprehensive status including passive mode
+app.get('/api/longrun/status-now', requireAdmin, async (req, res) => {
+  try {
+    const status = await waBootstrap.getWAStatus();
+    const isActive = waBootstrap.isActiveMode();
+    
+    // Get account statuses
+    const accountStatuses = [];
+    for (const [accountId, account] of connections.entries()) {
+      accountStatuses.push({
+        accountId,
+        name: account.name,
+        phone: account.phone,
+        status: account.status,
+        hasQR: !!account.qrCode,
+        sessionId: account.sessionId,
+      });
+    }
+    
+    res.json({
+      waMode: isActive ? 'active' : 'passive',
+      waStatus: status.waStatus || (isActive ? 'RUNNING' : 'NOT_RUNNING'),
+      instanceId: status.instanceId || 'unknown',
+      reason: status.reason || (isActive ? null : 'lock_not_acquired'),
+      lockStatus: status.lockStatus || 'unknown',
+      accounts: accountStatuses,
+      accountsCount: connections.size,
+      timestamp: new Date().toISOString(),
+    });
+  } catch (error) {
+    console.error('[status-now] Error:', error.message);
+    res.status(500).json({
+      error: error.message,
+      timestamp: new Date().toISOString(),
+    });
+  }
+});
+
 // Expose test token (temporary for orchestrator)
 app.get('/api/test/token', (req, res) => {
   if (Date.now() > TEST_TOKEN_EXPIRY) {
@@ -2950,6 +3046,11 @@ app.get('/api/whatsapp/qr/:accountId', async (req, res) => {
  *                   type: boolean
  */
 app.get('/api/whatsapp/accounts', async (req, res) => {
+  const requestId = req.headers['x-request-id'] || `req_${Date.now()}`;
+  const status = await waBootstrap.getWAStatus();
+  const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+  const isActive = waBootstrap.isActiveMode();
+  
   try {
     // Try cache first (if enabled)
     if (featureFlags.isEnabled('API_CACHING')) {
@@ -2957,7 +3058,14 @@ app.get('/api/whatsapp/accounts', async (req, res) => {
       const cached = await cache.get(cacheKey);
 
       if (cached) {
-        return res.json({ success: true, accounts: cached, cached: true });
+        return res.json({ 
+          success: true, 
+          accounts: cached, 
+          cached: true,
+          instanceId: instanceId,
+          waMode: isActive ? 'active' : 'passive',
+          requestId: requestId,
+        });
       }
     }
 
@@ -3097,11 +3205,21 @@ app.get('/api/whatsapp/qr-visual', async (req, res) => {
 
 // Add new account
 app.post('/api/whatsapp/add-account', accountLimiter, async (req, res) => {
+  const requestId = req.headers['x-request-id'] || `req_${Date.now()}`;
+  
   // HARD GATE: PASSIVE mode - do NOT create new Baileys connections
   if (!waBootstrap.canStartBaileys()) {
+    const status = await waBootstrap.getWAStatus();
+    const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+    console.log(`â¸ï¸  [add-account] Blocked: PASSIVE mode (instanceId: ${instanceId}, requestId: ${requestId})`);
     return res.status(503).json({
       success: false,
       error: 'PASSIVE mode: another instance holds lock; retry shortly',
+      message: `Backend in PASSIVE mode: ${status.reason || 'lock not acquired'}`,
+      mode: 'passive',
+      instanceId: instanceId,
+      waMode: 'passive',
+      requestId: requestId,
       mode: 'passive',
     });
   }
@@ -3189,16 +3307,40 @@ app.post('/api/whatsapp/add-account', accountLimiter, async (req, res) => {
       await cache.delete('whatsapp:accounts');
     }
 
+    // HARD GATE: PASSIVE mode - do NOT create connection (requires Baileys)
+    if (!waBootstrap.canStartBaileys()) {
+      const status = await waBootstrap.getWAStatus();
+      const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+      console.log(`â¸ï¸  [${accountId}] Add account blocked: PASSIVE mode (instanceId: ${instanceId})`);
+      return res.status(503).json({
+        success: false,
+        error: 'PASSIVE mode: another instance holds lock; retry shortly',
+        message: `Backend in PASSIVE mode: ${status.reason || 'lock not acquired'}`,
+        mode: 'passive',
+        instanceId: instanceId,
+        waMode: 'passive',
+        requestId: req.headers['x-request-id'] || `req_${Date.now()}`,
+      });
+    }
+
+    // Get instance info for response
+    const status = await waBootstrap.getWAStatus();
+    const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+    const isActive = waBootstrap.isActiveMode();
+    const requestId = req.headers['x-request-id'] || `req_${Date.now()}`;
+
+    console.log(`[${requestId}] Add account: accountId=${accountId}, instanceId=${instanceId}, waMode=${isActive ? 'active' : 'passive'}`);
+
     // Create connection (async, will emit QR later)
     createConnection(accountId, name, phone).catch(err => {
       console.error(`âŒ [${accountId}] Failed to create:`, err.message);
       Sentry.captureException(err, {
-        tags: { accountId, operation: 'create_connection' },
+        tags: { accountId, operation: 'create_connection', requestId },
         extra: { name, phone: maskPhone(canonicalPhoneNum) },
       });
     });
 
-    // Return immediately with connecting status
+    // Return immediately with connecting status + instance info
     res.json({
       success: true,
       account: {
@@ -3210,6 +3352,9 @@ app.post('/api/whatsapp/add-account', accountLimiter, async (req, res) => {
         pairingCode: null,
         createdAt: new Date().toISOString(),
       },
+      instanceId: instanceId,
+      waMode: isActive ? 'active' : 'passive',
+      requestId: requestId,
     });
   } catch (error) {
     Sentry.captureException(error, {
@@ -3363,15 +3508,22 @@ app.patch('/api/whatsapp/accounts/:accountId/name', accountLimiter, async (req,
 app.post('/api/whatsapp/regenerate-qr/:accountId', qrRegenerateLimiter, async (req, res) => {
   // DEBUG: Log incoming request
   const accountId = req.params.accountId;
-  console.log(`ðŸ” [DEBUG] Regenerate QR request: accountId=${accountId}, method=${req.method}, path=${req.path}`);
+  const requestId = req.headers['x-request-id'] || `req_${Date.now()}`;
+  console.log(`ðŸ” [${requestId}] Regenerate QR request: accountId=${accountId}, method=${req.method}, path=${req.path}`);
   
   // HARD GATE: PASSIVE mode - do NOT regenerate QR (requires Baileys connection)
   if (!waBootstrap.canStartBaileys()) {
-    console.log(`â¸ï¸  [${accountId}] Regenerate QR blocked: PASSIVE mode`);
+    const status = await waBootstrap.getWAStatus();
+    const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+    console.log(`â¸ï¸  [${accountId}] Regenerate QR blocked: PASSIVE mode (instanceId: ${instanceId}, requestId: ${requestId})`);
     return res.status(503).json({
       success: false,
       error: 'PASSIVE mode: another instance holds lock; retry shortly',
+      message: `Backend in PASSIVE mode: ${status.reason || 'lock not acquired'}`,
       mode: 'passive',
+      instanceId: instanceId,
+      waMode: 'passive',
+      requestId: requestId,
     });
   }
 
@@ -3444,10 +3596,22 @@ app.post('/api/whatsapp/regenerate-qr/:accountId', qrRegenerateLimiter, async (r
       updatedAt: admin.firestore.FieldValue.serverTimestamp(),
     });
 
+    // Get instance info for response
+    const status = await waBootstrap.getWAStatus();
+    const instanceId = status.instanceId || process.env.RAILWAY_DEPLOYMENT_ID || 'unknown';
+    const isActive = waBootstrap.isActiveMode();
+    const requestId = req.headers['x-request-id'] || `req_${Date.now()}`;
+
     // Create new connection (will generate fresh QR since session is cleared)
     await createConnection(accountId, account.name, account.phone);
 
-    res.json({ success: true, message: 'QR regeneration started' });
+    res.json({ 
+      success: true, 
+      message: 'QR regeneration started',
+      instanceId: instanceId,
+      waMode: isActive ? 'active' : 'passive',
+      requestId: requestId,
+    });
   } catch (error) {
     console.error(`âŒ Regenerate QR error:`, error);
     res.status(500).json({ success: false, error: error.message });
@@ -4502,11 +4666,21 @@ async function restoreAccount(accountId, data) {
     };
 
     // Set timeout to prevent "connecting forever" - CRITICAL FIX (configurable via env)
+    // CRITICAL: Only apply timeout for normal connecting, NOT for pairing phase (qr_ready/awaiting_scan)
     const CONNECTING_TIMEOUT = parseInt(process.env.WHATSAPP_CONNECT_TIMEOUT_MS || '60000', 10);
     account.connectingTimeout = setTimeout(() => {
       const timeoutSeconds = Math.floor(CONNECTING_TIMEOUT / 1000);
-      console.log(`â° [${accountId}] Connecting timeout (${timeoutSeconds}s), transitioning to disconnected`);
       const acc = connections.get(accountId);
+      
+      // CRITICAL FIX: Don't timeout if status is pairing phase (qr_ready, awaiting_scan, pairing)
+      // These states use QR_SCAN_TIMEOUT instead (10 minutes)
+      const isPairingPhase = acc && ['qr_ready', 'awaiting_scan', 'pairing'].includes(acc.status);
+      if (isPairingPhase) {
+        console.log(`â° [${accountId}] Connecting timeout skipped (status: ${acc.status} - pairing phase uses QR_SCAN_TIMEOUT)`);
+        return; // Don't timeout pairing phase
+      }
+      
+      console.log(`â° [${accountId}] Connecting timeout (${timeoutSeconds}s), transitioning to disconnected`);
       if (acc && acc.status === 'connecting') {
         acc.status = 'disconnected';
         acc.lastError = `Connection timeout - no progress after ${timeoutSeconds}s`;
