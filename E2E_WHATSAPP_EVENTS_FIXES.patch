diff --git a/functions/chatEventOps.js b/functions/chatEventOps.js
index dae96e1b..af050ea8 100644
--- a/functions/chatEventOps.js
+++ b/functions/chatEventOps.js
@@ -186,13 +186,19 @@ function sanitizeUpdateFields(data) {
   return out;
 }
 
-exports.chatEventOps = onCall(
-  { 
-    region: 'us-central1', 
-    timeoutSeconds: 30,
-    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
-  },
-  async (request) => {
+// Internal handler function (can be called directly or via onCall)
+async function chatEventOpsHandler(request) {
+  const requestId = request.data?.clientRequestId || `chatEventOps_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
+  const startTime = Date.now();
+  
+  try {
+    console.log(`[${requestId}] chatEventOps called`, {
+      uid: request.auth?.uid,
+      email: request.auth?.token?.email,
+      textLength: (request.data?.text || '').length,
+      dryRun: request.data?.dryRun === true,
+    });
+
     // Require authentication (all authenticated users can use this)
     const auth = requireAuth(request);
     const { uid, email } = auth;
@@ -201,7 +207,10 @@ exports.chatEventOps = onCall(
     const employeeInfo = await isEmployee(uid, email);
 
     const text = (request.data?.text || '').toString().trim();
-    if (!text) throw new HttpsError('invalid-argument', 'Lipsește "text".');
+    if (!text) {
+      console.error(`[${requestId}] Missing text parameter`);
+      throw new HttpsError('invalid-argument', 'Lipsește "text".');
+    }
 
     // DryRun mode: parse command but don't execute (for preview)
     const dryRun = request.data?.dryRun === true;
@@ -209,7 +218,7 @@ exports.chatEventOps = onCall(
     // Access GROQ API key from secret
     const groqKey = groqApiKey.value();
     if (!groqKey) {
-      console.error('[chatEventOps] GROQ_API_KEY not available');
+      console.error(`[${requestId}] GROQ_API_KEY not available`);
       throw new HttpsError('failed-precondition', 'Lipsește GROQ_API_KEY.');
     }
 
@@ -481,7 +490,14 @@ Dacă utilizatorul cere "șterge", întoarce action:"ARCHIVE" sau "NONE".
       }
 
       const ref = await db.collection('evenimente').add(doc);
-      return { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat și adăugat în Evenimente.`, dryRun: false };
+      const result = { ok: true, action: 'CREATE', eventId: ref.id, message: `Eveniment creat și adăugat în Evenimente.`, dryRun: false };
+      console.log(`[${requestId}] Event created`, {
+        eventId: ref.id,
+        eventShortId: doc.eventShortId,
+        date: doc.date,
+        address: doc.address,
+      });
+      return result;
     }
 
     if (action === 'UPDATE') {
@@ -627,8 +643,36 @@ Dacă utilizatorul cere "șterge", întoarce action:"ARCHIVE" sau "NONE".
       return { ok: true, action: 'UNARCHIVE', eventId, message: `Eveniment dezarhivat: ${eventId}`, dryRun: false };
     }
 
-    return { ok: false, action: 'NONE', message: `Acțiune necunoscută: ${action}`, raw };
+    const result = { ok: false, action: 'NONE', message: `Acțiune necunoscută: ${action}`, raw };
+    const duration = Date.now() - startTime;
+    console.log(`[${requestId}] chatEventOps completed`, {
+      action: result.action,
+      ok: result.ok,
+      durationMs: duration,
+    });
+    return result;
+  } catch (error) {
+    const duration = Date.now() - startTime;
+    console.error(`[${requestId}] chatEventOps error`, {
+      error: error.message,
+      stack: error.stack,
+      durationMs: duration,
+    });
+    throw error;
   }
+}
+
+// Export as onCall handler
+exports.chatEventOps = onCall(
+  { 
+    region: 'us-central1', 
+    timeoutSeconds: 30,
+    secrets: [groqApiKey]  // Attach GROQ_API_KEY secret
+  },
+  chatEventOpsHandler
 );
 
+// Export handler function for direct calls (e.g., from chatWithAI)
+exports.chatEventOpsHandler = chatEventOpsHandler;
+
 // Force redeploy Fri Jan  9 14:06:54 UTC 2026
diff --git a/functions/index.js b/functions/index.js
index db7cd048..4ea5b3ca 100644
--- a/functions/index.js
+++ b/functions/index.js
@@ -546,22 +546,38 @@ Scrie "da" pentru a confirma și crea evenimentul, sau "anulează" pentru a renu
 
         if (step === 'confirm') {
           if (userText === 'da' || userText === 'confirm' || userText === 'confirma') {
-            // Call chatEventOps to create event
-            const chatEventOps = require('./chatEventOps');
-            
+            // Call chatEventOps via exported callable (proper way)
             const eventText = `Notează eveniment pentru ${eventData.sarbatoritNume}, ${eventData.sarbatoritVarsta} ani, pe ${eventData.date} la ${eventData.address}`;
+            const clientRequestId = `interactive_${currentSessionId}_${Date.now()}`;
+            
+            console.log(`[${requestId}] Creating event via chatEventOps`, {
+              clientRequestId,
+              sessionId: currentSessionId,
+              eventData: {
+                name: eventData.sarbatoritNume,
+                age: eventData.sarbatoritVarsta,
+                date: eventData.date,
+                address: eventData.address,
+              },
+            });
             
             try {
-              const eventResult = await chatEventOps({
+              // Use the exported handler function directly (not the onCall wrapper)
+              const { chatEventOpsHandler } = require('./chatEventOps');
+              
+              // Call handler directly with request-like object
+              const eventResult = await chatEventOpsHandler({
                 data: {
                   text: eventText,
                   dryRun: false,
-                  clientRequestId: `interactive_${currentSessionId}_${Date.now()}`
+                  clientRequestId,
                 },
-                auth: request.auth
-              }, {
-                status: () => ({ json: () => {} }),
-                json: (data) => data
+                auth: request.auth,
+              });
+              
+              console.log(`[${requestId}] Event created successfully`, {
+                eventId: eventResult.eventId,
+                clientRequestId,
               });
               
               // Clear conversation state
@@ -575,7 +591,11 @@ Scrie "da" pentru a confirma și crea evenimentul, sau "anulează" pentru a renu
                 eventId: eventResult.eventId
               };
             } catch (error) {
-              console.error(`[${requestId}] Error creating event:`, error);
+              console.error(`[${requestId}] Error creating event:`, {
+                error: error.message,
+                stack: error.stack,
+                clientRequestId,
+              });
               await stateRef.delete();
               
               return {
diff --git a/functions/whatsappProxy.js b/functions/whatsappProxy.js
index f85b42ec..dea3ee18 100644
--- a/functions/whatsappProxy.js
+++ b/functions/whatsappProxy.js
@@ -478,12 +478,16 @@ async function getAccountsHandler(req, res) {
       // Lazy-load Railway base URL (computed at handler runtime, not module load time)
       const railwayBaseUrl = getRailwayBaseUrl();
       if (!railwayBaseUrl) {
+        console.error('[whatsappProxy/getAccounts] WHATSAPP_RAILWAY_BASE_URL missing');
+        console.error('[whatsappProxy/getAccounts] process.env.WHATSAPP_RAILWAY_BASE_URL:', process.env.WHATSAPP_RAILWAY_BASE_URL ? 'SET' : 'NOT SET');
         return res.status(500).json({
           success: false,
           error: 'configuration_missing',
           message: 'WHATSAPP_RAILWAY_BASE_URL must be set via environment variable or functions.config().whatsapp.railway_base_url',
         });
       }
+      
+      console.log('[whatsappProxy/getAccounts] Railway URL:', railwayBaseUrl.substring(0, 30) + '...');
 
       // Forward to Railway backend
       const railwayUrl = `${railwayBaseUrl}/api/whatsapp/accounts`;
diff --git a/superparty_flutter/lib/router/app_router.dart b/superparty_flutter/lib/router/app_router.dart
index 08f5e543..0e7d80ad 100644
--- a/superparty_flutter/lib/router/app_router.dart
+++ b/superparty_flutter/lib/router/app_router.dart
@@ -2,7 +2,7 @@ import 'dart:async';
 import 'dart:io';
 import 'dart:convert';
 
-import 'package:flutter/foundation.dart';
+import 'package:flutter/foundation.dart' show kDebugMode;
 import 'package:flutter/material.dart';
 import 'package:go_router/go_router.dart';
 
@@ -17,6 +17,7 @@ import '../screens/disponibilitate/disponibilitate_screen.dart';
 import '../screens/salarizare/salarizare_screen.dart';
 import '../screens/centrala/centrala_screen.dart';
 import '../screens/whatsapp/whatsapp_screen.dart';
+import '../screens/debug/whatsapp_diagnostics_screen.dart';
 import '../screens/whatsapp/whatsapp_accounts_screen.dart';
 import '../screens/whatsapp/whatsapp_inbox_screen.dart';
 import '../screens/whatsapp/whatsapp_chat_screen.dart';
@@ -116,6 +117,12 @@ class AppRouter {
           child: const WhatsAppScreen(),
         ),
         routes: [
+          // Debug diagnostics (only in debug mode)
+          if (kDebugMode)
+            GoRoute(
+              path: 'diagnostics',
+              builder: (context, state) => const WhatsAppDiagnosticsScreen(),
+            ),
           GoRoute(
             path: 'accounts',
             builder: (context, state) => AuthGate(
diff --git a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
index 58e367f6..86e30e71 100644
--- a/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
+++ b/superparty_flutter/lib/screens/ai_chat/ai_chat_screen.dart
@@ -372,6 +372,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         // Generate unique clientRequestId for idempotency
         final clientRequestId = 'req_${DateTime.now().millisecondsSinceEpoch}_${Random().nextInt(9999)}';
         
+        debugPrint('[AIChat] Calling chatEventOps (preview): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=true');
+        
         // Call chatEventOps with dryRun=true for preview
         final eventCallable =
             FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -385,6 +387,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
           'clientRequestId': clientRequestId,
         });
         
+        debugPrint('[AIChat] chatEventOps preview result: requestId=$clientRequestId, ok=${previewResult.data['ok']}, action=${previewResult.data['action']}');
+        
         final previewData = Map<String, dynamic>.from(previewResult.data);
         
         // Remove placeholder and show preview
@@ -1308,6 +1312,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
     });
     _scrollToBottomSoon();
 
+    debugPrint('[AIChat] Calling chatEventOps (create): requestId=$clientRequestId, textLength=${commandText.length}, dryRun=false');
+    
     try {
       final eventCallable =
           FirebaseFunctions.instanceFor(region: 'us-central1').httpsCallable(
@@ -1320,6 +1326,8 @@ class _AIChatScreenState extends State<AIChatScreen> {
         'dryRun': false,
         'clientRequestId': clientRequestId,
       });
+      
+      debugPrint('[AIChat] chatEventOps create result: requestId=$clientRequestId, ok=${result.data['ok']}, action=${result.data['action']}, eventId=${result.data['eventId']}');
 
       final data = Map<String, dynamic>.from(result.data);
       final ok = data['ok'] == true;
diff --git a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
index 4501cfc3..9a228d3e 100644
--- a/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
+++ b/superparty_flutter/lib/screens/evenimente/evenimente_screen.dart
@@ -2,6 +2,7 @@ import 'dart:ui' show ImageFilter;
 import 'dart:io';
 import 'dart:convert';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart' show debugPrint;
 import 'package:cloud_firestore/cloud_firestore.dart';
 import '../../models/event_model.dart';
 import '../../widgets/modals/range_modal.dart';
@@ -512,6 +513,7 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         }
 
         if (snapshot.hasError) {
+          debugPrint('[EvenimenteScreen] Firestore error: ${snapshot.error}');
           return Center(
             child: Text(
               'Eroare: ${snapshot.error}',
@@ -523,8 +525,14 @@ class _EvenimenteScreenState extends State<EvenimenteScreen> {
         final events = snapshot.data?.docs.map((doc) {
           return EventModel.fromFirestore(doc);
         }).toList() ?? [];
+        
+        debugPrint('[EvenimenteScreen] Loaded ${events.length} events from Firestore');
+        debugPrint('[EvenimenteScreen] Events with isArchived=false: ${events.where((e) => !e.isArchived).length}');
+        
         _allEvents = events; // Cache for CodeInfoModal
         final filteredEvents = _applyFilters(events);
+        
+        debugPrint('[EvenimenteScreen] Filtered events count: ${filteredEvents.length}');
 
         if (filteredEvents.isEmpty) {
           return Center(
diff --git a/superparty_flutter/lib/services/whatsapp_api_service.dart b/superparty_flutter/lib/services/whatsapp_api_service.dart
index cb8d90a5..55e3f6c9 100644
--- a/superparty_flutter/lib/services/whatsapp_api_service.dart
+++ b/superparty_flutter/lib/services/whatsapp_api_service.dart
@@ -132,12 +132,19 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] getAccounts: calling proxy (uid=${user.uid.substring(0, 8)}...)');
+      final endpointUrl = '$functionsUrl/whatsappProxyGetAccounts';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] getAccounts: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .get(
-            Uri.parse('$functionsUrl/whatsappProxyGetAccounts'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -146,7 +153,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] getAccounts: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] getAccounts: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
@@ -186,12 +195,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] addAccount: calling proxy (uid=${user.uid.substring(0, 8)}..., name=$name, phone=$phone)');
+      final endpointUrl = '$functionsUrl/whatsappProxyAddAccount';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] addAccount: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  name: $name, phone: $phone');
 
       // Call Functions proxy with Authorization header
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyAddAccount'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -204,7 +221,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] addAccount: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] addAccount: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
@@ -241,12 +260,20 @@ class WhatsAppApiService {
       final functionsUrl = _getFunctionsUrl();
       final requestId = _generateRequestId();
 
-      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy (uid=${user.uid.substring(0, 8)}..., accountId=$accountId)');
+      final endpointUrl = '$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId';
+      final hasToken = (token?.isNotEmpty ?? false);
+      
+      debugPrint('[WhatsAppApiService] regenerateQr: calling proxy');
+      debugPrint('  endpoint: $endpointUrl');
+      debugPrint('  uid: ${user.uid.substring(0, 8)}...');
+      debugPrint('  tokenPresent: $hasToken');
+      debugPrint('  requestId: $requestId');
+      debugPrint('  accountId: $accountId');
 
       // Call Functions proxy with Authorization header (query param for accountId)
       final response = await http
           .post(
-            Uri.parse('$functionsUrl/whatsappProxyRegenerateQr?accountId=$accountId'),
+            Uri.parse(endpointUrl),
             headers: {
               'Authorization': 'Bearer $token',
               'Content-Type': 'application/json',
@@ -255,7 +282,9 @@ class WhatsAppApiService {
           )
           .timeout(requestTimeout);
 
-      debugPrint('[WhatsAppApiService] regenerateQr: status=${response.statusCode}, bodyLength=${response.body.length}');
+      debugPrint('[WhatsAppApiService] regenerateQr: response');
+      debugPrint('  statusCode: ${response.statusCode}');
+      debugPrint('  bodyLength: ${response.body.length}');
 
       if (response.statusCode < 200 || response.statusCode >= 300) {
         final errorBody = jsonDecode(response.body) as Map<String, dynamic>?;
